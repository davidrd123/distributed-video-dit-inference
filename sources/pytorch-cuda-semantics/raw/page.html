
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content="A guide to torch.cuda, a PyTorch module to run CUDA operations" name="description" />
<meta content="memory management, PYTORCH_ALLOC_CONF, optimize PyTorch, CUDA" name="keywords" />

    <title>CUDA semantics &#8212; PyTorch 2.10 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=047068a3" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=949a1ff5" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/katex-math.css?v=91adb8b6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/css/jit.css?v=8de1ea5d" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=8998eb7a"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=940804e7"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notes/cuda';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://docs.pytorch.org/docs/pytorch-versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '2.10';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <script src="../_static/js/runllm-widget.js?v=54a6b3cb"></script>
    <link rel="canonical" href="https://docs.pytorch.org/docs/stable/notes/cuda.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PyTorch Custom Operators Landing Page" href="custom_operators.html" />
    <link rel="prev" title="CPU threading and TorchScript inference" href="cpu_threading_torchscript_inference.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/2.3.1/list.min.js"></script>
<script>
  if (window.location.hostname === 'docs.pytorch.org' || window.location.hostname === 'docs-preview.pytorch.org') {
    const script = document.createElement('script');
    script.src = 'https://cmp.osano.com/16A0DbT9yDNIaQkvZ/31b1b91a-e0b6-47ea-bde2-7f2bd13dbe5c/osano.js?variant=one';
    document.head.appendChild(script);
  }
</script>
<script>
  // Cookie banner for non-LF projects
  document.addEventListener('DOMContentLoaded', function () {
    // Hide cookie banner on local environments and LF owned docs
    if (window.location.hostname === 'localhost' ||
      window.location.hostname === '0.0.0.0' ||
      window.location.hostname === '127.0.0.1' ||
      window.location.hostname === 'docs.pytorch.org' ||
      window.location.hostname === 'docs-preview.pytorch.org' ||
      window.location.hostname.startsWith('192.168.')) {
      const banner = document.querySelector('.cookie-banner-wrapper');
      if (banner) {
        banner.style.display = 'none';
      }
    }
  });
</script>
<!-- Conditional CSS for header and footer height adjustment -->


<link rel="stylesheet" type="text/css" href="../_static/css/theme.css" crossorigin="anonymous">
<script type="text/javascript" src="../_static/js/theme.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400&display=swap" rel="stylesheet">
<meta property="og:image" content="https://docs.pytorch.org/docs/stable/_static/img/pytorch_seo.png" />
<link rel="stylesheet" href="../_static/webfonts/all.min.css" crossorigin="anonymous">
<meta http-equiv="Content-Security-Policy"
  content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:; style-src * 'unsafe-inline'; script-src * 'unsafe-inline' 'unsafe-eval' blob:;">
<meta name="pytorch_project" content="docs">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T8XT4PS" height="0" width="0"
    style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<!-- Google Tag Manager -->
<script>(function (w, d, s, l, i) {
    w[l] = w[l] || []; w[l].push({
      'gtm.start':
        new Date().getTime(), event: 'gtm.js'
    }); var f = d.getElementsByTagName(s)[0],
      j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
        'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
    j.onload = function () {
      window.dispatchEvent(new Event('gtm_loaded'));
      console.log('GTM loaded successfully');
    };
  })(window, document, 'script', 'dataLayer', 'GTM-T8XT4PS');
</script>
<!-- End Google Tag Manager -->
<!-- Facebook Pixel Code -->
<script>
  !function (f, b, e, v, n, t, s) {
    if (f.fbq) return; n = f.fbq = function () {
      n.callMethod ?
        n.callMethod.apply(n, arguments) : n.queue.push(arguments)
    };
    if (!f._fbq) f._fbq = n; n.push = n; n.loaded = !0; n.version = '2.0';
    n.queue = []; t = b.createElement(e); t.async = !0;
    t.src = v; s = b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t, s)
  }(window, document, 'script',
    'https://connect.facebook.net/en_US/fbevents.js');
  fbq('init', '243028289693773');
  fbq('track', 'PageView');
</script>
<script>
  document.documentElement.setAttribute('data-version', '2.10');
</script>
<noscript>
  <img height="1" width="1" src="https://www.facebook.com/tr?id=243028289693773&ev=PageView&noscript=1" />
</noscript>
<script>
  function gtag() {
    window.dataLayer.push(arguments);
  }
</script>
<!-- End Facebook Pixel Code -->
<!-- Repository configuration for tutorials -->

<!-- Script to Fix scrolling -->
<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Fix anchor scrolling
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const targetId = this.getAttribute('href').substring(1);
        const targetElement = document.getElementById(targetId);

        if (targetElement) {
          const headerHeight =
            (document.querySelector('.header-holder') ? document.querySelector('.header-holder').offsetHeight : 0) +
            (document.querySelector('.bd-header') ? document.querySelector('.bd-header').offsetHeight : 0) + 20;

          const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - headerHeight;
          window.scrollTo({
            top: targetPosition,
            behavior: 'smooth'
          });

          // Update URL hash without scrolling
          history.pushState(null, null, '#' + targetId);
        }
      });
    });
  });
</script>

<script async src="https://cse.google.com/cse.js?cx=e65585f8c3ea1440e"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>

  </head>

<body data-feedback-url="https://github.com/pytorch/pytorch" class="pytorch-body">
  
    <div class="container-fluid header-holder tutorials-header" id="header-holder">
   <div class="header-container-wrapper">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                <span>Learn</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/get-started/locally">
                  <span class=dropdown-title>Get Started</span>
                </a>
                <a class="nav-dropdown-item" href="https://docs.pytorch.org/tutorials">
                  <span class="dropdown-title">Tutorials</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/beginner/basics/intro.html">
                  <span class="dropdown-title">Learn the Basics</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/recipes/recipes_index.html">
                  <span class="dropdown-title">PyTorch Recipes</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/beginner/introyt.html">
                  <span class="dropdown-title">Intro to PyTorch - YouTube Series</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/webinars/">
                  <span class="dropdown-title">Webinars</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span>Community</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://landscape.pytorch.org/" target="_blank">
                  <span class="dropdown-title">Landscape</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/join-ecosystem">
                  <span class="dropdown-title">Join the Ecosystem</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/community-hub/">
                  <span class="dropdown-title">Community Hub</span>
                </a>
                <a class="nav-dropdown-item" href="https://discuss.pytorch.org/">
                  <span class="dropdown-title">Forums</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/resources">
                  <span class=dropdown-title>Developer Resources</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/contributor-awards/">
                  <span class="dropdown-title">Contributor Awards</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/community-events/">
                  <span class="dropdown-title">Community Events</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/programs/ambassadors/">
                  <span class="dropdown-title">PyTorch Ambassadors</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span>Projects</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/projects/pytorch/">
                  <span class="dropdown-title">PyTorch</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/projects/vllm/">
                  <span class="dropdown-title">vLLM</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/projects/deepspeed/">
                  <span class="dropdown-title">DeepSpeed</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/projects/host-your-project/">
                  <span class="dropdown-title">Host Your Project</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/projects/ray/">
                  <span class="dropdown-title">RAY</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span> Docs</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://docs.pytorch.org/docs/stable/index.html">
                  <span class="dropdown-title">PyTorch</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/domains">
                  <span class="dropdown-title">Domains</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span>Blogs & News</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/blog/">
                  <span class="dropdown-title">Blog</span>
                </a>
                 <a class="nav-dropdown-item" href="https://pytorch.org/announcements">
                  <span class="dropdown-title">Announcements</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/case-studies/">
                  <span class="dropdown-title">Case Studies</span>
                <a class="nav-dropdown-item" href="https://pytorch.org/events">
                  <span class="dropdown-title">Events</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/newsletter">
                  <span class="dropdown-title">Newsletter</span>
                </a>
            </div>
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span>About</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/foundation">
                  <span class="dropdown-title">PyTorch Foundation</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/members">
                  <span class="dropdown-title">Members</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/governing-board">
                  <span class="dropdown-title">Governing Board</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tac">
                  <span class="dropdown-title">Technical Advisory Council</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/credits">
                  <span class="dropdown-title">Cloud Credit Program</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/staff">
                  <span class="dropdown-title">Staff</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/contact">
                  <span class="dropdown-title">Contact</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/wp-content/uploads/2025/09/pytorch_brand_guide_091925a.pdf">
                  <span class="dropdown-title">Brand Guidelines</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div class="no-dropdown main-menu-button">
              <a href="https://pytorch.org/join" data-cta="join">
                JOIN
              </a>
            </div>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu">
        <i class="fa-solid fa-ellipsis"></i>
      </a>
    </div>
  </div>
 </div>

 <!-- Begin Mobile Menu -->

<div class="mobile-main-menu">
  <div class="container-fluid">
    <div class="header-container-wrapper">
      <div class="mobile-main-menu-header-container">
        <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu">
        </a>
      </div>
    </div>
  </div>

  <div class="mobile-main-menu-links-container">
    <div class="main-menu">
      <ul>
         <li class="resources-mobile-menu-title">
           <a>Learn</a>
         </li>
         <ul class="resources-mobile-menu-items">
           <li>
             <a href="https://pytorch.org/get-started/locally">Get Started</a>
           </li>
           <li>
             <a href="https://docs.pytorch.org/tutorials">Tutorials</a>
           </li>
           <li>
             <a href="https://pytorch.org/tutorials/beginner/basics/intro.html">Learn the Basics</a>
           </li>
           <li>
             <a href="https://pytorch.org/tutorials/recipes/recipes_index.html">PyTorch Recipes</a>
           </li>
           <li>
             <a href="https://pytorch.org/tutorials/beginner/introyt.html">Introduction to PyTorch - YouTube Series</a>
           </li>
           <li>
            <a href="https://pytorch.org/webinars/">Webinars</a>
          </li>
        </ul>
         <li class="resources-mobile-menu-title">
           <a>Community</a>
         </li>
         <ul class="resources-mobile-menu-items">
          <li>
            <a href="https://landscape.pytorch.org/">Landscape</a>
          </li>
          <li>
             <a href="https://pytorch.org/join-ecosystem">Join the Ecosystem</a>
           </li>
           <li>
             <a href="https://pytorch.org/community-hub/">Community Hub</a>
           </li>
           <li>
             <a href="https://discuss.pytorch.org/">Forums</a>
           </li>
           <li>
             <a href="https://pytorch.org/resources">Developer Resources</a>
           </li>
           <li>
             <a href="https://pytorch.org/contributor-awards/">Contributor Awards</a>
           </li>
           <li>
            <a href="https://pytorch.org/community-events/">Community Events</a>
          </li>
          <li>
            <a href="https://pytorch.org/programs/ambassadors/">PyTorch Ambassadors</a>
          </li>
       </ul>

         <li class="resources-mobile-menu-title">
           <a>Projects</a>
         </li>

         <ul class="resources-mobile-menu-items">
           <li>
             <a href="https://pytorch.org/projects/pytorch/">PyTorch</a>
           </li>

           <li>
             <a href="https://pytorch.org/projects/vllm/">vLLM</a>
           </li>
           <li>
            <a href="https://pytorch.org/projects/deepspeed/">DeepSpeed</a>
          </li>
          <li>
             <a href="https://pytorch.org/projects/host-your-project/">Host Your Project</a>
           </li>
         </ul>

         <li class="resources-mobile-menu-title">
           <a>Docs</a>
         </li>

         <ul class="resources-mobile-menu-items">
          <li>
            <a href="https://docs.pytorch.org/docs/stable/index.html">PyTorch</a>
          </li>

          <li>
            <a href="https://pytorch.org/domains">Domains</a>
          </li>
        </ul>

        <li class="resources-mobile-menu-title">
          <a>Blog & News</a>
        </li>

         <ul class="resources-mobile-menu-items">
          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>
          <li>
            <a href="https://pytorch.org/announcements">Announcements</a>
          </li>

          <li>
            <a href="https://pytorch.org/case-studies/">Case Studies</a>
          </li>
          <li>
            <a href="https://pytorch.org/events">Events</a>
          </li>
          <li>
             <a href="https://pytorch.org/newsletter">Newsletter</a>
           </li>
        </ul>

        <li class="resources-mobile-menu-title">
          <a>About</a>
        </li>

        <ul class="resources-mobile-menu-items">
          <li>
            <a href="https://pytorch.org/foundation">PyTorch Foundation</a>
          </li>
          <li>
            <a href="https://pytorch.org/members">Members</a>
          </li>
          <li>
            <a href="https://pytorch.org/governing-board">Governing Board</a>
          </li>
          <li>
            <a href="https://pytorch.org/tac">Technical Advisory Council</a>
         </li>
         <li>
             <a href="https://pytorch.org/credits">Cloud Credit Program</a>
          </li>
          <li>
             <a href="https://pytorch.org/staff">Staff</a>
          </li>
          <li>
             <a href="https://pytorch.org/contact">Contact</a>
          </li>
        </ul>
      </ul>
    </div>
  </div>
</div>

<!-- End Mobile Menu -->
  
  
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Home</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-external" href="https://pytorch.org/get-started/locally/">
    Install PyTorch
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="../user_guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../pytorch-api.html">
    Reference API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../notes.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../community/index.html">
    Community
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://docs.pytorch.org/tutorials/">
    Tutorials
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">
<div class="search-container-wrapper">
  <div id="sphinx-search" class="search-container">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </div>

  <div id="google-search" class="search-container" style="display:none;">
    <div class="gcse-search-wrapper">
      <i class="fa-solid fa-magnifying-glass" aria-hidden="true"></i>
      <div class="gcse-search"></div>
    </div>
  </div>

  <div class="search-toggle-container" data-bs-title="Google Search Off" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <div class="search-toggle-inner">
      <label class="switch">
        <input type="checkbox" id="search-toggle">
        <span class="slider round"></span>
      </label>
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
  // Define the search callback
  const myWebSearchStartingCallback = (gname, query) => {
    if (typeof dataLayer !== 'undefined' && query) {
      window.dataLayer = window.dataLayer || [];
      dataLayer.push({
        'event': 'google_search',
        'search_term': query,
        'event_category': 'Search',
        'event_label': 'Google Search'
      });
    }
    return '';
  };

  // Set up the GCSE search callbacks
  window.__gcse || (window.__gcse = {});
  window.__gcse.searchCallbacks = {
    web: { starting: myWebSearchStartingCallback }
  };

  if (window.location.pathname.includes('/search.html')) {
    document.body.classList.add('search-page');
  }

  // Function to reinitialize Google CSE
  function reinitializeGoogleSearch() {
    if (window.__gcse && window.__gcse.initializationCallback) {
      window.__gcse.initializationCallback();
    }
  }

  // Function to handle search toggle
  function handleSearchToggle(toggle, sphinxSearch, googleSearch) {
    if (!toggle || !sphinxSearch || !googleSearch) return;

    // Check if the URL contains /stable/ or /tutorials/
    const currentUrl = window.location.href;
    // TODO: We've had reports that the google programmable search is returning stale documentation,
    //       Simple reproduction is to turn google search on and search for multinomial which will
    //       result in returning 1.8.1 documentation.
    //       We should turn this back on when we resolve that bug.
    const shouldDefaultToGoogle = false;
    const savedPreference = localStorage.getItem('searchPreference');

    // Set initial state
    if (savedPreference === 'google' || (savedPreference === null && shouldDefaultToGoogle)) {
      toggle.checked = true;
      sphinxSearch.style.display = 'none';
      googleSearch.style.display = 'block';
      if (savedPreference === null) {
        localStorage.setItem('searchPreference', 'google');
      }
      reinitializeGoogleSearch();
    } else {
      toggle.checked = false;
      sphinxSearch.style.display = 'block';
      googleSearch.style.display = 'none';
    }

    // Update tooltip
    updateTooltip(toggle.checked);

    // Skip if already initialized
    if (toggle.hasAttribute('data-initialized')) return;
    toggle.setAttribute('data-initialized', 'true');

    toggle.addEventListener('change', function() {
      if (this.checked) {
        sphinxSearch.style.display = 'none';
        googleSearch.style.display = 'block';
        localStorage.setItem('searchPreference', 'google');
        reinitializeGoogleSearch();
        trackSearchEngineSwitch('Google');
      } else {
        sphinxSearch.style.display = 'block';
        googleSearch.style.display = 'none';
        localStorage.setItem('searchPreference', 'sphinx');
        trackSearchEngineSwitch('Sphinx');
      }

      updateTooltip(this.checked);
      updateMobileSearch();
    });
  }

  // Update tooltip based on toggle state
  function updateTooltip(isChecked) {
    const tooltipElement = document.querySelector('.search-toggle-container');
    if (!tooltipElement) return;

    tooltipElement.setAttribute('data-bs-title', isChecked ? 'Google Search On' : 'Google Search Off');

    if (bootstrap && bootstrap.Tooltip) {
      const tooltipInstance = bootstrap.Tooltip.getInstance(tooltipElement);
      if (tooltipInstance) tooltipInstance.dispose();
      new bootstrap.Tooltip(tooltipElement);
    }
  }

  // Track search engine switch
  function trackSearchEngineSwitch(engine) {
    if (typeof dataLayer !== 'undefined') {
      window.dataLayer = window.dataLayer || [];
      dataLayer.push({
        'event': 'search_engine_switch',
        'event_category': 'Search',
        'event_label': engine
      });
    }
  }

  // Function to update mobile search based on current toggle state
  function updateMobileSearch() {
    const toggle = document.getElementById('search-toggle');
    if (!toggle) return;

    const mobileSearchContainer = document.querySelector('.sidebar-header-items__end .navbar-item .search-container-wrapper');
    if (!mobileSearchContainer) return;

    const mobileSphinxSearch = mobileSearchContainer.querySelector('#sphinx-search');
    const mobileGoogleSearch = mobileSearchContainer.querySelector('#google-search');

    if (mobileSphinxSearch && mobileGoogleSearch) {
      mobileSphinxSearch.style.display = toggle.checked ? 'none' : 'block';
      mobileGoogleSearch.style.display = toggle.checked ? 'block' : 'none';

      if (toggle.checked) {
        reinitializeGoogleSearch();
      }
    }
  }

  // Initialize desktop search toggle
  const toggle = document.getElementById('search-toggle');
  const sphinxSearch = document.getElementById('sphinx-search');
  const googleSearch = document.getElementById('google-search');
  handleSearchToggle(toggle, sphinxSearch, googleSearch);

  // Set placeholder text for Google search input
  const observer = new MutationObserver(function() {
    document.querySelectorAll('.gsc-input input').forEach(input => {
      if (input && !input.hasAttribute('data-placeholder-set')) {
        input.setAttribute('placeholder', 'Search the docs ...');
        input.setAttribute('data-placeholder-set', 'true');
      }
    });
  });

  observer.observe(document.body, { childList: true, subtree: true });

  // Fix for scroll jump issue - improved approach
  function setupSearchInputHandlers(input) {
    if (input.hasAttribute('data-scroll-fixed')) return;
    input.setAttribute('data-scroll-fixed', 'true');

    let lastScrollPosition = 0;
    let isTyping = false;
    let scrollTimeout;

    // Save position before typing starts
    input.addEventListener('keydown', () => {
      lastScrollPosition = window.scrollY;
      isTyping = true;

      // Reset typing state after a short delay
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isTyping = false;
      }, 100);
    });

    // Only maintain scroll position during typing
    function maintainScroll() {
      if (document.activeElement === input && isTyping) {
        window.scrollTo(0, lastScrollPosition);
        requestAnimationFrame(maintainScroll);
      }
    }

    input.addEventListener('focus', () => {
      // Just store initial position but don't force it
      lastScrollPosition = window.scrollY;
    });

    input.addEventListener('input', () => {
      isTyping = true;
      window.scrollTo(0, lastScrollPosition);

      // Reset typing state after a short delay
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isTyping = false;
      }, 100);

      requestAnimationFrame(maintainScroll);
    });
  }

  // Apply to all search inputs and observe for new ones
  function applyToSearchInputs() {
    document.querySelectorAll('.search-container input, .gsc-input input').forEach(setupSearchInputHandlers);
  }

  applyToSearchInputs();

  const searchObserver = new MutationObserver(applyToSearchInputs);
  searchObserver.observe(document.body, { childList: true, subtree: true });

  // Watch for mobile menu creation
  const mobileMenuObserver = new MutationObserver(function(mutations) {
    for (const mutation of mutations) {
      if (!mutation.addedNodes.length) continue;

      // Style mobile search inputs
      document.querySelectorAll('.sidebar-header-items__end .navbar-item .search-container-wrapper .gsc-input input').forEach(input => {
        if (input) {
          input.setAttribute('placeholder', 'Search the docs ...');
          input.style.paddingLeft = '36px';
        }
      });

      // Check for mobile search container
      const mobileSearchContainer = document.querySelector('.sidebar-header-items__end .navbar-item .search-container-wrapper');
      if (!mobileSearchContainer) continue;

      const mobileToggle = mobileSearchContainer.querySelector('#search-toggle');
      if (mobileToggle && toggle) {
        // Sync mobile toggle with desktop toggle
        mobileToggle.checked = toggle.checked;
        updateMobileSearch();

        // Add event listener to mobile toggle if not already added
        if (!mobileToggle.hasAttribute('data-initialized')) {
          mobileToggle.setAttribute('data-initialized', 'true');
          mobileToggle.addEventListener('change', function() {
            // Sync desktop toggle with mobile toggle
            toggle.checked = this.checked;
            // Trigger change event on desktop toggle to update both
            toggle.dispatchEvent(new Event('change'));
          });
        }
      }
    }
  });

  mobileMenuObserver.observe(document.body, { childList: true, subtree: true });

  // Ensure Google CSE is properly loaded
  if (window.__gcse) {
    window.__gcse.callback = function() {
      // This will run after Google CSE is fully loaded
      if (toggle && toggle.checked) {
        reinitializeGoogleSearch();
      }
    };
  } else {
    window.__gcse = {
      callback: function() {
        if (toggle && toggle.checked) {
          reinitializeGoogleSearch();
        }
      }
    };
  }
});
</script>
</div>
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/pytorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://discuss.pytorch.org/" title="PyTorch Forum" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discourse fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyTorch Forum</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torch/" title="PyPi" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPi</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-external" href="https://pytorch.org/get-started/locally/">
    Install PyTorch
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="../user_guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../pytorch-api.html">
    Reference API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../notes.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../community/index.html">
    Community
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://docs.pytorch.org/tutorials/">
    Tutorials
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<div class="search-container-wrapper">
  <div id="sphinx-search" class="search-container">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </div>

  <div id="google-search" class="search-container" style="display:none;">
    <div class="gcse-search-wrapper">
      <i class="fa-solid fa-magnifying-glass" aria-hidden="true"></i>
      <div class="gcse-search"></div>
    </div>
  </div>

  <div class="search-toggle-container" data-bs-title="Google Search Off" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <div class="search-toggle-inner">
      <label class="switch">
        <input type="checkbox" id="search-toggle">
        <span class="slider round"></span>
      </label>
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
  // Define the search callback
  const myWebSearchStartingCallback = (gname, query) => {
    if (typeof dataLayer !== 'undefined' && query) {
      window.dataLayer = window.dataLayer || [];
      dataLayer.push({
        'event': 'google_search',
        'search_term': query,
        'event_category': 'Search',
        'event_label': 'Google Search'
      });
    }
    return '';
  };

  // Set up the GCSE search callbacks
  window.__gcse || (window.__gcse = {});
  window.__gcse.searchCallbacks = {
    web: { starting: myWebSearchStartingCallback }
  };

  if (window.location.pathname.includes('/search.html')) {
    document.body.classList.add('search-page');
  }

  // Function to reinitialize Google CSE
  function reinitializeGoogleSearch() {
    if (window.__gcse && window.__gcse.initializationCallback) {
      window.__gcse.initializationCallback();
    }
  }

  // Function to handle search toggle
  function handleSearchToggle(toggle, sphinxSearch, googleSearch) {
    if (!toggle || !sphinxSearch || !googleSearch) return;

    // Check if the URL contains /stable/ or /tutorials/
    const currentUrl = window.location.href;
    // TODO: We've had reports that the google programmable search is returning stale documentation,
    //       Simple reproduction is to turn google search on and search for multinomial which will
    //       result in returning 1.8.1 documentation.
    //       We should turn this back on when we resolve that bug.
    const shouldDefaultToGoogle = false;
    const savedPreference = localStorage.getItem('searchPreference');

    // Set initial state
    if (savedPreference === 'google' || (savedPreference === null && shouldDefaultToGoogle)) {
      toggle.checked = true;
      sphinxSearch.style.display = 'none';
      googleSearch.style.display = 'block';
      if (savedPreference === null) {
        localStorage.setItem('searchPreference', 'google');
      }
      reinitializeGoogleSearch();
    } else {
      toggle.checked = false;
      sphinxSearch.style.display = 'block';
      googleSearch.style.display = 'none';
    }

    // Update tooltip
    updateTooltip(toggle.checked);

    // Skip if already initialized
    if (toggle.hasAttribute('data-initialized')) return;
    toggle.setAttribute('data-initialized', 'true');

    toggle.addEventListener('change', function() {
      if (this.checked) {
        sphinxSearch.style.display = 'none';
        googleSearch.style.display = 'block';
        localStorage.setItem('searchPreference', 'google');
        reinitializeGoogleSearch();
        trackSearchEngineSwitch('Google');
      } else {
        sphinxSearch.style.display = 'block';
        googleSearch.style.display = 'none';
        localStorage.setItem('searchPreference', 'sphinx');
        trackSearchEngineSwitch('Sphinx');
      }

      updateTooltip(this.checked);
      updateMobileSearch();
    });
  }

  // Update tooltip based on toggle state
  function updateTooltip(isChecked) {
    const tooltipElement = document.querySelector('.search-toggle-container');
    if (!tooltipElement) return;

    tooltipElement.setAttribute('data-bs-title', isChecked ? 'Google Search On' : 'Google Search Off');

    if (bootstrap && bootstrap.Tooltip) {
      const tooltipInstance = bootstrap.Tooltip.getInstance(tooltipElement);
      if (tooltipInstance) tooltipInstance.dispose();
      new bootstrap.Tooltip(tooltipElement);
    }
  }

  // Track search engine switch
  function trackSearchEngineSwitch(engine) {
    if (typeof dataLayer !== 'undefined') {
      window.dataLayer = window.dataLayer || [];
      dataLayer.push({
        'event': 'search_engine_switch',
        'event_category': 'Search',
        'event_label': engine
      });
    }
  }

  // Function to update mobile search based on current toggle state
  function updateMobileSearch() {
    const toggle = document.getElementById('search-toggle');
    if (!toggle) return;

    const mobileSearchContainer = document.querySelector('.sidebar-header-items__end .navbar-item .search-container-wrapper');
    if (!mobileSearchContainer) return;

    const mobileSphinxSearch = mobileSearchContainer.querySelector('#sphinx-search');
    const mobileGoogleSearch = mobileSearchContainer.querySelector('#google-search');

    if (mobileSphinxSearch && mobileGoogleSearch) {
      mobileSphinxSearch.style.display = toggle.checked ? 'none' : 'block';
      mobileGoogleSearch.style.display = toggle.checked ? 'block' : 'none';

      if (toggle.checked) {
        reinitializeGoogleSearch();
      }
    }
  }

  // Initialize desktop search toggle
  const toggle = document.getElementById('search-toggle');
  const sphinxSearch = document.getElementById('sphinx-search');
  const googleSearch = document.getElementById('google-search');
  handleSearchToggle(toggle, sphinxSearch, googleSearch);

  // Set placeholder text for Google search input
  const observer = new MutationObserver(function() {
    document.querySelectorAll('.gsc-input input').forEach(input => {
      if (input && !input.hasAttribute('data-placeholder-set')) {
        input.setAttribute('placeholder', 'Search the docs ...');
        input.setAttribute('data-placeholder-set', 'true');
      }
    });
  });

  observer.observe(document.body, { childList: true, subtree: true });

  // Fix for scroll jump issue - improved approach
  function setupSearchInputHandlers(input) {
    if (input.hasAttribute('data-scroll-fixed')) return;
    input.setAttribute('data-scroll-fixed', 'true');

    let lastScrollPosition = 0;
    let isTyping = false;
    let scrollTimeout;

    // Save position before typing starts
    input.addEventListener('keydown', () => {
      lastScrollPosition = window.scrollY;
      isTyping = true;

      // Reset typing state after a short delay
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isTyping = false;
      }, 100);
    });

    // Only maintain scroll position during typing
    function maintainScroll() {
      if (document.activeElement === input && isTyping) {
        window.scrollTo(0, lastScrollPosition);
        requestAnimationFrame(maintainScroll);
      }
    }

    input.addEventListener('focus', () => {
      // Just store initial position but don't force it
      lastScrollPosition = window.scrollY;
    });

    input.addEventListener('input', () => {
      isTyping = true;
      window.scrollTo(0, lastScrollPosition);

      // Reset typing state after a short delay
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isTyping = false;
      }, 100);

      requestAnimationFrame(maintainScroll);
    });
  }

  // Apply to all search inputs and observe for new ones
  function applyToSearchInputs() {
    document.querySelectorAll('.search-container input, .gsc-input input').forEach(setupSearchInputHandlers);
  }

  applyToSearchInputs();

  const searchObserver = new MutationObserver(applyToSearchInputs);
  searchObserver.observe(document.body, { childList: true, subtree: true });

  // Watch for mobile menu creation
  const mobileMenuObserver = new MutationObserver(function(mutations) {
    for (const mutation of mutations) {
      if (!mutation.addedNodes.length) continue;

      // Style mobile search inputs
      document.querySelectorAll('.sidebar-header-items__end .navbar-item .search-container-wrapper .gsc-input input').forEach(input => {
        if (input) {
          input.setAttribute('placeholder', 'Search the docs ...');
          input.style.paddingLeft = '36px';
        }
      });

      // Check for mobile search container
      const mobileSearchContainer = document.querySelector('.sidebar-header-items__end .navbar-item .search-container-wrapper');
      if (!mobileSearchContainer) continue;

      const mobileToggle = mobileSearchContainer.querySelector('#search-toggle');
      if (mobileToggle && toggle) {
        // Sync mobile toggle with desktop toggle
        mobileToggle.checked = toggle.checked;
        updateMobileSearch();

        // Add event listener to mobile toggle if not already added
        if (!mobileToggle.hasAttribute('data-initialized')) {
          mobileToggle.setAttribute('data-initialized', 'true');
          mobileToggle.addEventListener('change', function() {
            // Sync desktop toggle with mobile toggle
            toggle.checked = this.checked;
            // Trigger change event on desktop toggle to update both
            toggle.dispatchEvent(new Event('change'));
          });
        }
      }
    }
  });

  mobileMenuObserver.observe(document.body, { childList: true, subtree: true });

  // Ensure Google CSE is properly loaded
  if (window.__gcse) {
    window.__gcse.callback = function() {
      // This will run after Google CSE is fully loaded
      if (toggle && toggle.checked) {
        reinitializeGoogleSearch();
      }
    };
  } else {
    window.__gcse = {
      callback: function() {
        if (toggle && toggle.checked) {
          reinitializeGoogleSearch();
        }
      }
    };
  }
});
</script>
</div>
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/pytorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://discuss.pytorch.org/" title="PyTorch Forum" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discourse fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyTorch Forum</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torch/" title="PyPi" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPi</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference external" href="https://docs.pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html">Pytorch Overview</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/get-started/locally/">Get Started</a></li>
<li class="toctree-l1"><a class="reference external" href="https://docs.pytorch.org/tutorials/beginner/basics/intro.html">Learn the Basics</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Core Concepts</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../user_guide/pytorch_main_components.html">PyTorch Main Components</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Torch Compile</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler.html">Torch.compile</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_get_started.html">Getting Started</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../user_guide/torch_compiler/core_concepts.html">Core Concepts</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../user_guide/torch_compiler/compile/programming_model.html">torch.compile Programming Model</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/programming_model.dynamo_core_concepts.html">Dynamo Core Concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/programming_model.graph_breaks_index.html">Working with Graph Breaks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/programming_model.non_strict_tracing_model.html">Non-strict Tracing Programming Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/programming_model.recompilation.html">Dealing with Recompilations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/programming_model.observability.html">tlparse / TORCH_TRACE</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/programming_model.reporting_issues.html">Reporting Issues</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_dynamo_overview.html">Dynamo Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_nn_module.html">PyTorch 2.0 NNModule Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_backward.html"><code class="docutils literal notranslate"><span class="pre">torch.compile</span></code> has different autograd semantics</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../user_guide/torch_compiler/performance.html">Performance</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_performance_dashboard.html">PyTorch 2.0 Performance Dashboard</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_inductor_profiling.html">TorchInductor GPU Profiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_profiling_torch_compile.html">Profiling to understand torch.compile performance</a></li>

<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_cudagraph_trees.html">CUDAGraph Trees</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../user_guide/torch_compiler/advanced.html">Advanced</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_dynamo_deepdive.html">Dynamo Deep-Dive</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_transformations.html">Writing Graph Transformations on ATen IR</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_fake_tensor.html">Fake tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_custom_backends.html">Custom Backends</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_dynamic_shapes.html">Dynamic Shapes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_core_concepts.html">Dynamic Shapes Core Concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_troubleshooting.html">Troubleshooting Dynamic Shapes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_advanced_control_options.html">Advanced Options to Control Dynamic Behavior</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_beyond_the_basics.html">Beyond the Basics</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../user_guide/torch_compiler/troubleshooting_faqs.html">Troubleshooting FAQs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/compile/programming_model.observability.html">tlparse / TORCH_TRACE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/compile/programming_model.reporting_issues.html">Reporting Issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_troubleshooting.html">torch.compile Troubleshooting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_faq.html">Frequently Asked Questions</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../user_guide/torch_compiler/api_reference.html">Reference/API</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../torch.compiler_api.html">torch.compiler API reference</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.compile.html">torch.compiler.compile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.reset.html">torch.compiler.reset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.allow_in_graph.html">torch.compiler.allow_in_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.substitute_in_graph.html">torch.compiler.substitute_in_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.assume_constant_result.html">torch.compiler.assume_constant_result</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.list_backends.html">torch.compiler.list_backends</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.disable.html">torch.compiler.disable</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.set_stance.html">torch.compiler.set_stance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.set_enable_guard_collectives.html">torch.compiler.set_enable_guard_collectives</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.cudagraph_mark_step_begin.html">torch.compiler.cudagraph_mark_step_begin</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.is_compiling.html">torch.compiler.is_compiling</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.is_dynamo_compiling.html">torch.compiler.is_dynamo_compiling</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.is_exporting.html">torch.compiler.is_exporting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.skip_guard_on_inbuilt_nn_modules_unsafe.html">torch.compiler.skip_guard_on_inbuilt_nn_modules_unsafe</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.skip_guard_on_all_nn_modules_unsafe.html">torch.compiler.skip_guard_on_all_nn_modules_unsafe</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.keep_tensor_guards_unsafe.html">torch.compiler.keep_tensor_guards_unsafe</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.skip_guard_on_globals_unsafe.html">torch.compiler.skip_guard_on_globals_unsafe</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.skip_all_guards_unsafe.html">torch.compiler.skip_all_guards_unsafe</a></li>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch.compiler.nested_compile_region.html">torch.compiler.nested_compile_region</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler.config.html">torch.compiler.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_fine_grain_apis.html">TorchDynamo APIs for fine-grained tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_inductor_provenance.html">TorchInductor and AOTInductor Provenance Tracking</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../user_guide/torch_compiler/export.html">Torch.export</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/export/api_reference.html">torch.export API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/export/programming_model.html">torch.export Programming Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/export/ir_spec.html">torch.export IR Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/export/pt2_archive.html">PT2 Archive Spec</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/export/draft_export.html">Draft Export</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/export/joint_with_descriptors.html">Joint with descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cond.html">Control Flow - Cond</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../generated/exportdb/index.html">ExportDB</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/torch.escape-hatch.html">torch.escape-hatch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/torch.cond.html">torch.cond</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/torch.dynamic-shape.html">torch.dynamic-shape</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/python.closure.html">python.closure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/torch.dynamic-value.html">torch.dynamic-value</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/python.data-structure.html">python.data-structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/python.assert.html">python.assert</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/python.control-flow.html">python.control-flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/torch.map.html">torch.map</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/python.builtin.html">python.builtin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/python.object-model.html">python.object-model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/python.context-manager.html">python.context-manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/torch.operator.html">torch.operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generated/exportdb/torch.mutation.html">torch.mutation</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_aot_inductor.html">AOTInductor: Ahead-Of-Time Compilation for Torch.Export-ed Models</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../logging.html">torch._logging</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../generated/torch._logging.set_logs.html">torch._logging.set_logs</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_aot_inductor_minifier.html">AOTInductor Minifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_aot_inductor_debugging_guide.html">AOTInductor Debugging Guide</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_ir.html">IRs</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_dynamic_shapes.html">Dynamic Shapes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_core_concepts.html">Dynamic Shapes Core Concepts</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_troubleshooting.html">Troubleshooting Dynamic Shapes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_debugging_tlparse_torch_logs.html">Debugging with <code class="docutils literal notranslate"><span class="pre">tlparse</span></code> and <code class="docutils literal notranslate"><span class="pre">TORCH_LOGS=dynamic</span></code></a></li>

<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_troubleshooting_guardon_errors.html">Troubleshooting GuardOnDataDependentSymNode Errors</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_advanced_control_options.html">Advanced Options to Control Dynamic Behavior</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_beyond_the_basics.html">Beyond the Basics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_zero_one_specialization.html">The Zero-One Specialization Problem</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_guide/torch_compiler/compile/dynamic_shapes_backed_unbacked.html">Backed vs Unbacked Symints</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_fake_tensor.html">Fake tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user_guide/torch_compiler/torch.compiler_transformations.html">Writing Graph Transformations on ATen IR</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../notes.html">Developer Notes</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="amp_examples.html">Automatic Mixed Precision examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="autograd.html">Autograd mechanics</a></li>
<li class="toctree-l2"><a class="reference internal" href="broadcasting.html">Broadcasting semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="cpu_threading_torchscript_inference.html">CPU threading and TorchScript inference</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">CUDA semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="custom_operators.html">PyTorch Custom Operators Landing Page</a></li>
<li class="toctree-l2"><a class="reference internal" href="ddp.html">Distributed Data Parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="extending.html">Extending PyTorch</a></li>
<li class="toctree-l2"><a class="reference internal" href="extending.func.html">Extending torch.func with autograd.Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="get_start_xpu.html">Getting Started on Intel GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="gradcheck.html">Gradcheck mechanics</a></li>
<li class="toctree-l2"><a class="reference internal" href="hip.html">HIP (ROCm) semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="large_scale_deployments.html">Features for large-scale deployments</a></li>
<li class="toctree-l2"><a class="reference internal" href="libtorch_stable_abi.html">LibTorch Stable ABI</a></li>
<li class="toctree-l2"><a class="reference internal" href="mkldnn.html">MKLDNN backend</a></li>

<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="mps.html">MPS backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="multiprocessing.html">Multiprocessing best practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="numerical_accuracy.html">Numerical accuracy</a></li>
<li class="toctree-l2"><a class="reference internal" href="out.html">Out Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="randomness.html">Reproducibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="serialization.html">Serialization semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="windows.html">Windows FAQ</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Accelerator Integration</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../accelerator/index.html">Accelerator Integration</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../accelerator/device.html">Device Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../accelerator/hooks.html">Accelerator Hooks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../accelerator/guard.html">Guard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../accelerator/autoload.html">Autoload Mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../accelerator/operators.html">Operator Registration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../accelerator/amp.html">Automatic Mixed Precision</a></li>
</ul>
</details></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../user_guide/index.html" class="nav-link">User Guide</a></li>
    
    
    <li class="breadcrumb-item"><a href="../notes.html" class="nav-link">Developer Notes</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">CUDA semantics</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">
<div class="rating">
    Rate this Page
    <div class="stars">
        
        <span class="star" data-behavior="tutorial-rating" data-count="1" data-value="1"></span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="2" data-value="2"></span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="3" data-value="3"></span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="4" data-value="4"></span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="5" data-value="5"></span>
        
    </div>
</div>
</div>
      
    </div>
  
</div>
</div>
              
              
  
<div id="searchbox"></div>
  <article class="bd-article" id="pytorch-article">
    <!-- Hidden breadcrumb schema for SEO only -->
    <div style="display:none;" itemscope itemtype="https://schema.org/BreadcrumbList">
      
      <div itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
        <link itemprop="item" href="../user_guide/index.html">
        <meta itemprop="name" content="User Guide">
        <meta itemprop="position" content="1">
      </div>
      
      <div itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
        <link itemprop="item" href="../notes.html">
        <meta itemprop="name" content="Developer Notes">
        <meta itemprop="position" content="2">
      </div>
      
      <div itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
        <meta itemprop="name" content="CUDA semantics">
        <meta itemprop="position" content="3">
      </div>
    </div>

    
    

    
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="cuda-semantics">
<span id="id1"></span><h1>CUDA semantics<a class="headerlink" href="#cuda-semantics" title="Link to this heading">#</a></h1>
<p class="date-info-last-verified" style="color: #6c6c6d; font-size: small;">Created On: Jan 16, 2017 | Last Updated On: Dec 09, 2025</p>
<p><a class="reference internal" href="../cuda.html#module-torch.cuda" title="torch.cuda"><code class="xref py py-mod docutils literal notranslate"><span class="pre">torch.cuda</span></code></a> is used to set up and run CUDA operations. It keeps track of
the currently selected GPU, and all CUDA tensors you allocate will by default be
created on that device. The selected device can be changed with a
<a class="reference internal" href="../generated/torch.cuda.device.html#torch.cuda.device" title="torch.cuda.device"><code class="xref any py py-class docutils literal notranslate"><span class="pre">torch.cuda.device</span></code></a> context manager.</p>
<p>However, once a tensor is allocated, you can do operations on it irrespective
of the selected device, and the results will be always placed on the same
device as the tensor.</p>
<p>Cross-GPU operations are not allowed by default, with the exception of
<a class="reference internal" href="../generated/torch.Tensor.copy_.html#torch.Tensor.copy_" title="torch.Tensor.copy_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy_()</span></code></a> and other methods with copy-like functionality
such as <a class="reference internal" href="../generated/torch.Tensor.to.html#torch.Tensor.to" title="torch.Tensor.to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to()</span></code></a> and <a class="reference internal" href="../generated/torch.Tensor.cuda.html#torch.Tensor.cuda" title="torch.Tensor.cuda"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cuda()</span></code></a>.
Unless you enable peer-to-peer memory access, any attempts to launch ops on
tensors spread across different devices will raise an error.</p>
<p>Below you can find a small example showcasing this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>     <span class="c1"># Default CUDA device</span>
<span class="n">cuda0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda:0&#39;</span><span class="p">)</span>
<span class="n">cuda2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda:2&#39;</span><span class="p">)</span>  <span class="c1"># GPU 2 (these are 0-indexed)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda0</span><span class="p">)</span>
<span class="c1"># x.device is device(type=&#39;cuda&#39;, index=0)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="c1"># y.device is device(type=&#39;cuda&#39;, index=0)</span>

<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># allocates a tensor on GPU 1</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span>

    <span class="c1"># transfers a tensor from CPU to GPU 1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
    <span class="c1"># a.device and b.device are device(type=&#39;cuda&#39;, index=1)</span>

    <span class="c1"># You can also use ``Tensor.to`` to transfer a tensor:</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span>
    <span class="c1"># b.device and b2.device are device(type=&#39;cuda&#39;, index=1)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="c1"># c.device is device(type=&#39;cuda&#39;, index=1)</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="c1"># z.device is device(type=&#39;cuda&#39;, index=0)</span>

    <span class="c1"># even within a context, you can specify the device</span>
    <span class="c1"># (or give a GPU index to the .cuda call)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda2</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">cuda2</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">(</span><span class="n">cuda2</span><span class="p">)</span>
    <span class="c1"># d.device, e.device, and f.device are all device(type=&#39;cuda&#39;, index=2)</span>
</pre></div>
</div>
<section id="tensorfloat-32-tf32-on-ampere-and-later-devices">
<span id="tf32-on-ampere"></span><h2>TensorFloat-32 (TF32) on Ampere (and later) devices<a class="headerlink" href="#tensorfloat-32-tf32-on-ampere-and-later-devices" title="Link to this heading">#</a></h2>
<p>After Pytorch 2.9, we provide a new sets of APIs to control the TF32 behavior in a more fine-grained way, and
suggest to use the new APIs for better control.
We can set float32 precision per backend and per operators. We can also override the global setting for a specific operator.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;ieee&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;ieee&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;ieee&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;tf32&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">rnn</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;tf32&quot;</span>
</pre></div>
</div>
<p>The fp32_precision can be set to <cite>ieee</cite> or <cite>tf32</cite> for <cite>cuda/cudnn</cite>.
<cite>ieee</cite> fp32_precision indicate that we will use <cite>FP32</cite> as internal computation precision.
<cite>tf32</cite> fp32_precision indicate that we will allow to use <cite>TF32</cite> as internal computation precision.</p>
<p>We can override a generic setting for a specific operator if the fp32_precision is set to <cite>ieee</cite>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;tf32&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;ieee&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">rnn</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;ieee&quot;</span>
</pre></div>
</div>
<p>We can also override a generic setting for a specific backend if the fp32_precision is set to <cite>ieee</cite>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;tf32&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;ieee&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">conv</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;ieee&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">rnn</span><span class="o">.</span><span class="n">fp32_precision</span> <span class="o">=</span> <span class="s2">&quot;ieee&quot;</span>
</pre></div>
</div>
<p>For above 2 cases, both <cite>torch.backends.cudnn.conv.fp32_precision</cite> and <cite>torch.backends.cudnn.rnn.fp32_precision</cite>
is overridden to <cite>ieee</cite>.</p>
<p>We suggest to use the new settings for better control. And we do not support to use mix of old and new settings.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Old settings with <cite>allow_tf32</cite> as follows is going to be deprecated. We suggest to use the above new settings for
better control. And we do not support to use mix of old and new settings.</p>
</div>
<p>Starting in PyTorch 1.7, there is a new flag called <cite>allow_tf32</cite>. This flag
defaults to True in PyTorch 1.7 to PyTorch 1.11, and False in PyTorch 1.12 and later.
This flag controls whether PyTorch is allowed to use the TensorFloat32 (TF32) tensor cores,
available on NVIDIA GPUs since Ampere, internally to compute matmul (matrix multiplies
and batched matrix multiplies) and convolutions.</p>
<p>TF32 tensor cores are designed to achieve better performance on matmul and convolutions on
<cite>torch.float32</cite> tensors by rounding input data to have 10 bits of mantissa, and accumulating
results with FP32 precision, maintaining FP32 dynamic range.</p>
<p>matmuls and convolutions are controlled separately, and their corresponding flags can be accessed at:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The flag below controls whether to allow TF32 on matmul. This flag defaults to False</span>
<span class="c1"># in PyTorch 1.12 and later.</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># The flag below controls whether to allow TF32 on cuDNN. This flag defaults to True.</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>The precision of matmuls can also be set more broadly (limited not just to CUDA) via <a class="reference internal" href="../generated/torch.set_float32_matmul_precision.html#torch.set_float32_matmul_precision" title="torch.set_float32_matmul_precision"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_float32_matmul_precision()</span></code></a>.
Note that besides matmuls and convolutions themselves, functions and nn modules that internally uses
matmuls or convolutions are also affected. These include <cite>nn.Linear</cite>, <cite>nn.Conv*</cite>, cdist, tensordot,
affine grid and grid sample, adaptive log softmax, GRU and LSTM.</p>
<p>To get an idea of the precision and speed, see the example code and benchmark data (on A100) below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a_full</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10240</span><span class="p">,</span> <span class="mi">10240</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">b_full</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10240</span><span class="p">,</span> <span class="mi">10240</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">ab_full</span> <span class="o">=</span> <span class="n">a_full</span> <span class="o">@</span> <span class="n">b_full</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">ab_full</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># 80.7277</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">a_full</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">b_full</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

<span class="c1"># Do matmul at TF32 mode.</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">ab_tf32</span> <span class="o">=</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b</span>  <span class="c1"># takes 0.016s on GA100</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">ab_tf32</span> <span class="o">-</span> <span class="n">ab_full</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c1"># 0.1747</span>
<span class="n">relative_error</span> <span class="o">=</span> <span class="n">error</span> <span class="o">/</span> <span class="n">mean</span>  <span class="c1"># 0.0022</span>

<span class="c1"># Do matmul with TF32 disabled.</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">ab_fp32</span> <span class="o">=</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b</span>  <span class="c1"># takes 0.11s on GA100</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">ab_fp32</span> <span class="o">-</span> <span class="n">ab_full</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c1"># 0.0031</span>
<span class="n">relative_error</span> <span class="o">=</span> <span class="n">error</span> <span class="o">/</span> <span class="n">mean</span>  <span class="c1"># 0.000039</span>
</pre></div>
</div>
<p>From the above example, we can see that with TF32 enabled, the speed is ~7x faster on A100, and that
relative error compared to double precision is approximately 2 orders of magnitude larger. Note that
the exact ratio of TF32 to single precision speed depends on the hardware generation, as properties
such as the ratio of memory bandwidth to compute as well as the ratio of TF32 to FP32 matmul throughput
may vary from generation to generation or model to model.
If full FP32 precision is needed, users can disable TF32 by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>To toggle the TF32 flags off in C++, you can do</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">at</span><span class="o">::</span><span class="n">globalContext</span><span class="p">().</span><span class="n">setAllowTF32CuBLAS</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="n">at</span><span class="o">::</span><span class="n">globalContext</span><span class="p">().</span><span class="n">setAllowTF32CuDNN</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>For more information about TF32, see:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://blogs.nvidia.com/blog/2020/05/14/tensorfloat-32-precision-format/">TensorFloat-32</a></p></li>
<li><p><a class="reference external" href="https://devblogs.nvidia.com/cuda-11-features-revealed/">CUDA 11</a></p></li>
<li><p><a class="reference external" href="https://devblogs.nvidia.com/nvidia-ampere-architecture-in-depth/">Ampere architecture</a></p></li>
</ul>
</section>
<section id="reduced-precision-reduction-in-fp16-gemms">
<span id="fp16reducedprecision"></span><h2>Reduced Precision Reduction in FP16 GEMMs<a class="headerlink" href="#reduced-precision-reduction-in-fp16-gemms" title="Link to this heading">#</a></h2>
<p>(Distinct from full FP16 accumulation that is intended for hardware that has higher throughput
with FP16 accumulation than FP32 accumulation, see <a class="reference internal" href="#fp16accumulation"><span class="std std-ref">Full FP16 accumulation</span></a>)</p>
<p>fp16 GEMMs are potentially done with some intermediate reduced precision reductions (e.g., in fp16 rather than fp32). These selective reductions in precision can allow for higher performance on certain workloads (particularly those with a large <cite>k</cite> dimension) and GPU architectures at the cost of numerical precision and potential for overflow.</p>
<p>Some example benchmark data on V100:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">---------------------------</span> <span class="n">bench_gemm_transformer</span> <span class="o">--------------------------</span><span class="p">]</span>
      <span class="p">[</span>  <span class="n">m</span> <span class="p">,</span>  <span class="n">k</span>  <span class="p">,</span>  <span class="n">n</span>  <span class="p">]</span>    <span class="o">|</span>  <span class="n">allow_fp16_reduc</span><span class="o">=</span><span class="kc">True</span>  <span class="o">|</span>  <span class="n">allow_fp16_reduc</span><span class="o">=</span><span class="kc">False</span>
<span class="mi">1</span> <span class="n">threads</span><span class="p">:</span> <span class="o">--------------------------------------------------------------------</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4048</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1634.6</span>        <span class="o">|</span>           <span class="mf">1639.8</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4056</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1670.8</span>        <span class="o">|</span>           <span class="mf">1661.9</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4080</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1664.2</span>        <span class="o">|</span>           <span class="mf">1658.3</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1639.4</span>        <span class="o">|</span>           <span class="mf">1651.0</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4104</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1677.4</span>        <span class="o">|</span>           <span class="mf">1674.9</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4128</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1655.7</span>        <span class="o">|</span>           <span class="mf">1646.0</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4144</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1796.8</span>        <span class="o">|</span>           <span class="mf">2519.6</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">5096</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">2094.6</span>        <span class="o">|</span>           <span class="mf">3190.0</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">5104</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">2144.0</span>        <span class="o">|</span>           <span class="mf">2663.5</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">5112</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">2149.1</span>        <span class="o">|</span>           <span class="mf">2766.9</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">5120</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">2142.8</span>        <span class="o">|</span>           <span class="mf">2631.0</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">9728</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">3875.1</span>        <span class="o">|</span>           <span class="mf">5779.8</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">16384</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>   <span class="o">|</span>           <span class="mf">6182.9</span>        <span class="o">|</span>           <span class="mf">9656.5</span>
<span class="p">(</span><span class="n">times</span> <span class="ow">in</span> <span class="n">microseconds</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>If full precision reductions are needed, users can disable reduced precision reductions in fp16 GEMMs with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_fp16_reduced_precision_reduction</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>To toggle the reduced precision reduction flags in C++, one can do</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">at</span><span class="o">::</span><span class="n">globalContext</span><span class="p">().</span><span class="n">setAllowFP16ReductionCuBLAS</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="reduced-precision-reduction-in-bf16-gemms">
<span id="bf16reducedprecision"></span><h2>Reduced Precision Reduction in BF16 GEMMs<a class="headerlink" href="#reduced-precision-reduction-in-bf16-gemms" title="Link to this heading">#</a></h2>
<p>A similar flag (as above) exists for BFloat16 GEMMs.
Note that this switch is set to <cite>True</cite> by default for BF16, if you observe
numerical instability in your workload, you may wish to set it to <cite>False</cite>.</p>
<p>If reduced precision reductions are not desired, users can disable reduced
precision reductions in bf16 GEMMs with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_bf16_reduced_precision_reduction</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>To toggle the reduced precision reduction flags in C++, one can do</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">at</span><span class="o">::</span><span class="n">globalContext</span><span class="p">().</span><span class="n">setAllowBF16ReductionCuBLAS</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="full-fp16-accumulation-in-fp16-gemms">
<span id="fp16accumulation"></span><h2>Full FP16 Accumulation in FP16 GEMMs<a class="headerlink" href="#full-fp16-accumulation-in-fp16-gemms" title="Link to this heading">#</a></h2>
<p>Certain GPUs have increased performance when doing _all_ FP16 GEMM accumulation
in FP16, at the cost of numerical precision and greater likelihood of overflow.
Note that this setting only has an effect on GPUs of compute capability 7.0 (Volta)
or newer.</p>
<p>This behavior can be enabled via:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_fp16_accumulation</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>To toggle the reduced precision reduction flags in C++, one can do</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">at</span><span class="o">::</span><span class="n">globalContext</span><span class="p">().</span><span class="n">setAllowFP16AccumulationCuBLAS</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="asynchronous-execution">
<h2>Asynchronous execution<a class="headerlink" href="#asynchronous-execution" title="Link to this heading">#</a></h2>
<p>By default, GPU operations are asynchronous.  When you call a function that
uses the GPU, the operations are <em>enqueued</em> to the particular device, but not
necessarily executed until later.  This allows us to execute more computations
in parallel, including operations on CPU or other GPUs.</p>
<p>In general, the effect of asynchronous computation is invisible to the caller,
because (1) each device executes operations in the order they are queued, and
(2) PyTorch automatically performs necessary synchronization when copying data
between CPU and GPU or between two GPUs.  Hence, computation will proceed as if
every operation was executed synchronously.</p>
<p>You can force synchronous computation by setting environment variable
<code class="docutils literal notranslate"><span class="pre">CUDA_LAUNCH_BLOCKING=1</span></code>.  This can be handy when an error occurs on the GPU.
(With asynchronous execution, such an error isnt reported until after the
operation is actually executed, so the stack trace does not show where it was
requested.)</p>
<p>A consequence of the asynchronous computation is that time measurements without
synchronizations are not accurate. To get precise measurements, one should either
call <a class="reference internal" href="../generated/torch.cuda.synchronize.html#torch.cuda.synchronize" title="torch.cuda.synchronize"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.synchronize()</span></code></a> before measuring, or use <a class="reference internal" href="../generated/torch.cuda.Event.html#torch.cuda.Event" title="torch.cuda.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.Event</span></code></a>
to record times as following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">start_event</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">enable_timing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">end_event</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">enable_timing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">start_event</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>

<span class="c1"># Run some things here</span>

<span class="n">end_event</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>  <span class="c1"># Wait for the events to be recorded!</span>
<span class="n">elapsed_time_ms</span> <span class="o">=</span> <span class="n">start_event</span><span class="o">.</span><span class="n">elapsed_time</span><span class="p">(</span><span class="n">end_event</span><span class="p">)</span>
</pre></div>
</div>
<p>As an exception, several functions such as <a class="reference internal" href="../generated/torch.Tensor.to.html#torch.Tensor.to" title="torch.Tensor.to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to()</span></code></a> and
<a class="reference internal" href="../generated/torch.Tensor.copy_.html#torch.Tensor.copy_" title="torch.Tensor.copy_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy_()</span></code></a> admit an explicit <code class="xref py py-attr docutils literal notranslate"><span class="pre">non_blocking</span></code> argument,
which lets the caller bypass synchronization when it is unnecessary.
Another exception is CUDA streams, explained below.</p>
<section id="cuda-streams">
<h3>CUDA streams<a class="headerlink" href="#cuda-streams" title="Link to this heading">#</a></h3>
<p>A <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#streams">CUDA stream</a> is a linear sequence of execution that belongs to a specific
device.  You normally do not need to create one explicitly: by default, each
device uses its own default stream.</p>
<p>Operations inside each stream are serialized in the order they are created,
but operations from different streams can execute concurrently in any
relative order, unless explicit synchronization functions (such as
<a class="reference internal" href="../generated/torch.cuda.synchronize.html#torch.cuda.synchronize" title="torch.cuda.synchronize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">synchronize()</span></code></a> or <a class="reference internal" href="../generated/torch.cuda.Stream_class.html#torch.cuda.Stream.wait_stream" title="torch.cuda.Stream.wait_stream"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_stream()</span></code></a>) are
used.  For example, the following code is incorrect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>  <span class="c1"># Create a new stream.</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="c1"># sum() may start execution before normal_() finishes!</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>When the current stream is the default stream, PyTorch automatically performs
necessary synchronization when data is moved around, as explained above.
However, when using non-default streams, it is the users responsibility to
ensure proper synchronization.  The fixed version of this example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>  <span class="c1"># Create a new stream.</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">default_stream</span><span class="p">(</span><span class="n">cuda</span><span class="p">))</span>  <span class="c1"># NEW!</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">record_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># NEW!</span>
</pre></div>
</div>
<p>There are two new additions.  The <a class="reference internal" href="../generated/torch.cuda.Stream_class.html#torch.cuda.Stream.wait_stream" title="torch.cuda.Stream.wait_stream"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.cuda.Stream.wait_stream()</span></code></a> call
ensures that the <code class="docutils literal notranslate"><span class="pre">normal_()</span></code> execution has finished before we start running
<code class="docutils literal notranslate"><span class="pre">sum(A)</span></code> on a side stream.  The <a class="reference internal" href="../generated/torch.Tensor.record_stream.html#torch.Tensor.record_stream" title="torch.Tensor.record_stream"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.record_stream()</span></code></a> (see for
more details) ensures that we do not deallocate A before <code class="docutils literal notranslate"><span class="pre">sum(A)</span></code> has
completed.  You can also manually wait on the stream at some later point in
time with <code class="docutils literal notranslate"><span class="pre">torch.cuda.default_stream(cuda).wait_stream(s)</span></code> (note that it
is pointless to wait immediately, since that will prevent the stream execution
from running in parallel with other work on the default stream.)  See the
documentation for <a class="reference internal" href="../generated/torch.Tensor.record_stream.html#torch.Tensor.record_stream" title="torch.Tensor.record_stream"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.record_stream()</span></code></a> on more details on when
to use one or another.</p>
<p>Note that this synchronization is necessary even when there is no
read dependency, e.g., as seen in this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>  <span class="c1"># Create a new stream.</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">default_stream</span><span class="p">(</span><span class="n">cuda</span><span class="p">))</span>  <span class="c1"># STILL REQUIRED!</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">A</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">record_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Despite the computation on <code class="docutils literal notranslate"><span class="pre">s</span></code> not reading the contents of <code class="docutils literal notranslate"><span class="pre">A</span></code> and no
other uses of <code class="docutils literal notranslate"><span class="pre">A</span></code>, it is still necessary to synchronize, because <code class="docutils literal notranslate"><span class="pre">A</span></code>
may correspond to memory reallocated by the CUDA caching allocator, with
pending operations from the old (deallocated) memory.</p>
</section>
<section id="stream-semantics-of-backward-passes">
<span id="bwd-cuda-stream-semantics"></span><h3>Stream semantics of backward passes<a class="headerlink" href="#stream-semantics-of-backward-passes" title="Link to this heading">#</a></h3>
<p>Each backward CUDA op runs on the same stream that was used for its corresponding forward op.
If your forward pass runs independent ops in parallel on different streams,
this helps the backward pass exploit that same parallelism.</p>
<p>The stream semantics of a backward call with respect to surrounding ops are the same
as for any other call. The backward pass inserts internal syncs to ensure this even when
backward ops run on multiple streams as described in the previous paragraph.
More concretely, when calling
<a class="reference internal" href="../generated/torch.autograd.backward.html#torch.autograd.backward" title="torch.autograd.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">autograd.backward</span></code></a>,
<a class="reference internal" href="../generated/torch.autograd.grad.html#torch.autograd.grad" title="torch.autograd.grad"><code class="xref py py-func docutils literal notranslate"><span class="pre">autograd.grad</span></code></a>, or
<a class="reference internal" href="../generated/torch.Tensor.backward.html#torch.Tensor.backward" title="torch.Tensor.backward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tensor.backward</span></code></a>,
and optionally supplying CUDA tensor(s) as the  initial gradient(s) (e.g.,
<a class="reference internal" href="../generated/torch.autograd.backward.html#torch.autograd.backward" title="torch.autograd.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">autograd.backward(...,</span> <span class="pre">grad_tensors=initial_grads)</span></code></a>,
<a class="reference internal" href="../generated/torch.autograd.grad.html#torch.autograd.grad" title="torch.autograd.grad"><code class="xref py py-func docutils literal notranslate"><span class="pre">autograd.grad(...,</span> <span class="pre">grad_outputs=initial_grads)</span></code></a>, or
<a class="reference internal" href="../generated/torch.Tensor.backward.html#torch.Tensor.backward" title="torch.Tensor.backward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tensor.backward(...,</span> <span class="pre">gradient=initial_grad)</span></code></a>),
the acts of</p>
<ol class="arabic simple">
<li><p>optionally populating initial gradient(s),</p></li>
<li><p>invoking the backward pass, and</p></li>
<li><p>using the gradients</p></li>
</ol>
<p>have the same stream-semantics relationship as any group of ops:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>

<span class="c1"># Safe, grads are used in the same stream context as backward()</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">use</span> <span class="n">grads</span>

<span class="c1"># Unsafe</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">use</span> <span class="n">grads</span>

<span class="c1"># Safe, with synchronization</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">use</span> <span class="n">grads</span>

<span class="c1"># Safe, populating initial grad and invoking backward are in the same stream context</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">gradient</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">loss</span><span class="p">))</span>

<span class="c1"># Unsafe, populating initial_grad and invoking backward are in different stream contexts,</span>
<span class="c1"># without synchronization</span>
<span class="n">initial_grad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">gradient</span><span class="o">=</span><span class="n">initial_grad</span><span class="p">)</span>

<span class="c1"># Safe, with synchronization</span>
<span class="n">initial_grad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">initial_grad</span><span class="o">.</span><span class="n">record_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">gradient</span><span class="o">=</span><span class="n">initial_grad</span><span class="p">)</span>
</pre></div>
</div>
<section id="bc-note-using-grads-on-the-default-stream">
<h4>BC note: Using grads on the default stream<a class="headerlink" href="#bc-note-using-grads-on-the-default-stream" title="Link to this heading">#</a></h4>
<p>In prior versions of PyTorch (1.9 and earlier), the autograd engine always synced
the default stream with all backward ops, so the following pattern:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">use</span> <span class="n">grads</span>
</pre></div>
</div>
<p>was safe as long as <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">grads</span></code> happened on the default stream.
In present PyTorch, that pattern is no longer safe. If <code class="docutils literal notranslate"><span class="pre">backward()</span></code>
and <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">grads</span></code> are in different stream contexts, you must sync the streams:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">use</span> <span class="n">grads</span>
</pre></div>
</div>
<p>even if <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">grads</span></code> is on the default stream.</p>
</section>
</section>
</section>
<section id="memory-management">
<span id="cuda-memory-management"></span><h2>Memory management<a class="headerlink" href="#memory-management" title="Link to this heading">#</a></h2>
<p>PyTorch uses a caching memory allocator to speed up memory allocations. This
allows fast memory deallocation without device synchronizations. However, the
unused memory managed by the allocator will still show as if used in
<code class="docutils literal notranslate"><span class="pre">nvidia-smi</span></code>. You can use <code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_allocated()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">max_memory_allocated()</span></code> to monitor memory occupied by
tensors, and use <code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_reserved()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">max_memory_reserved()</span></code> to monitor the total amount of memory
managed by the caching allocator. Calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">empty_cache()</span></code>
releases all <strong>unused</strong> cached memory from PyTorch so that those can be used
by other GPU applications. However, the occupied GPU memory by tensors will not
be freed so it can not increase the amount of GPU memory available for PyTorch.</p>
<p>To better understand how CUDA memory is being used over time,
<a class="reference internal" href="../torch_cuda_memory.html#torch-cuda-memory"><span class="std std-ref">Understanding CUDA Memory Usage</span></a> describes tools for capturing and visualizing traces of memory use.</p>
<p>For more advanced users, we offer more comprehensive memory benchmarking via
<code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_stats()</span></code>. We also offer the capability to capture a
complete snapshot of the memory allocator state via
<code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_snapshot()</span></code>, which can help you understand the
underlying allocation patterns produced by your code.</p>
<section id="optimizing-memory-usage-with-pytorch-alloc-conf">
<span id="cuda-memory-envvars"></span><h3>Optimizing memory usage  with <code class="docutils literal notranslate"><span class="pre">PYTORCH_ALLOC_CONF</span></code><a class="headerlink" href="#optimizing-memory-usage-with-pytorch-alloc-conf" title="Link to this heading">#</a></h3>
<p>Use of a caching allocator can interfere with memory checking tools such as
<code class="docutils literal notranslate"><span class="pre">cuda-memcheck</span></code>.  To debug memory errors using <code class="docutils literal notranslate"><span class="pre">cuda-memcheck</span></code>, set
<code class="docutils literal notranslate"><span class="pre">PYTORCH_NO_CUDA_MEMORY_CACHING=1</span></code> in your environment to disable caching.</p>
<p>The behavior of the caching allocator can be controlled via the environment variable
<code class="docutils literal notranslate"><span class="pre">PYTORCH_ALLOC_CONF</span></code>. <code class="docutils literal notranslate"><span class="pre">PYTORCH_CUDA_ALLOC_CONF</span></code> is its alias and is provided only
for backward compatibility.
The format is <code class="docutils literal notranslate"><span class="pre">PYTORCH_ALLOC_CONF=&lt;option&gt;:&lt;value&gt;,&lt;option2&gt;:&lt;value2&gt;...</span></code>
Available options:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">backend</span></code> allows selecting the underlying allocator implementation.
Currently, valid options are <code class="docutils literal notranslate"><span class="pre">native</span></code>, which uses PyTorchs native
implementation, and <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code>, which uses
<a class="reference external" href="https://developer.nvidia.com/blog/using-cuda-stream-ordered-memory-allocator-part-1/">CUDAs built-in asynchronous allocator</a>.
<code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> requires CUDA 11.4 or newer. The default is <code class="docutils literal notranslate"><span class="pre">native</span></code>.
<code class="docutils literal notranslate"><span class="pre">backend</span></code> applies to all devices used by the process, and cant be
specified on a per-device basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_split_size_mb</span></code> prevents the native allocator
from splitting blocks larger than this size (in MB). This can reduce
fragmentation and may allow some borderline workloads to complete without
running out of memory. Performance cost can range from zero to substantial
depending on allocation patterns.  Default value is unlimited, i.e. all blocks
can be split. The
<code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_stats()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_summary()</span></code> methods are useful for tuning.  This
option should be used as a last resort for a workload that is aborting
due to out of memory and showing a large amount of inactive split blocks.
<code class="docutils literal notranslate"><span class="pre">max_split_size_mb</span></code> is only meaningful with <code class="docutils literal notranslate"><span class="pre">backend:native</span></code>.
With <code class="docutils literal notranslate"><span class="pre">backend:cudaMallocAsync</span></code>, <code class="docutils literal notranslate"><span class="pre">max_split_size_mb</span></code> is ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">roundup_power2_divisions</span></code> helps with rounding the requested allocation
size to nearest power-2 division and making better use of the blocks. In
the native CUDACachingAllocator, the sizes are rounded up in multiple
of blocks size of 512, so this works fine for smaller sizes. However, this
can be inefficient for large near-by allocations as each will go to different
size of blocks and reuse of those blocks are minimized. This might create
lots of unused blocks and will waste GPU memory capacity. This option enables
the rounding of allocation size to nearest power-2 division. For example, if
we need to round-up size of 1200 and if number of divisions is 4,
the size 1200 lies between 1024 and 2048 and if we do 4 divisions between
them, the values are 1024, 1280, 1536, and 1792. So, allocation size of 1200
will be rounded to 1280 as the nearest ceiling of power-2 division.
Specify a single value to apply for all allocation sizes or specify an
array of key value pairs to set power-2 division individually for each
power of two interval. For example to set 1 division for all allocations
under 256MB, 2 division for allocations between 256MB and 512MB, 4 divisions
for allocations between 512MB and 1GB and 8 divisions for any larger allocations,
set the knob value to: [256:1,512:2,1024:4,&gt;:8].
<code class="docutils literal notranslate"><span class="pre">roundup_power2_divisions</span></code> is only meaningful with <code class="docutils literal notranslate"><span class="pre">backend:native</span></code>.
With <code class="docutils literal notranslate"><span class="pre">backend:cudaMallocAsync</span></code>, <code class="docutils literal notranslate"><span class="pre">roundup_power2_divisions</span></code> is ignored.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">max_non_split_rounding_mb</span></code> will allow non-split blocks for better reuse, eg,</dt><dd><p>a 1024MB cached block can be reused for a 512MB allocation request. In the default
case, we only allow up to 20MB of rounding of non-split blocks, so a 512MB block
can only be served with between 512-532 MB size block. If we set the value of this
option to 1024, it will allow 512-1536 MB size blocks to be used for a 512MB block
which increases reuse of larger blocks. This will also help in reducing the stalls
in avoiding expensive cudaMalloc calls.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">garbage_collection_threshold</span></code> helps actively reclaiming unused GPU memory to
avoid triggering expensive sync-and-reclaim-all operation (release_cached_blocks),
which can be unfavorable to latency-critical GPU applications (e.g., servers).
Upon setting this threshold (e.g., 0.8), the allocator will start reclaiming
GPU memory blocks if the GPU memory capacity usage exceeds the threshold (i.e.,
80% of the total memory allocated to the GPU application). The algorithm prefers
to free old &amp; unused blocks first to avoid freeing blocks that are actively being
reused. The threshold value should be between greater than 0.0 and less than 1.0.
The default value is set at 1.0.</p>
<p><code class="docutils literal notranslate"><span class="pre">garbage_collection_threshold</span></code> is only meaningful with <code class="docutils literal notranslate"><span class="pre">backend:native</span></code>.
With <code class="docutils literal notranslate"><span class="pre">backend:cudaMallocAsync</span></code>, <code class="docutils literal notranslate"><span class="pre">garbage_collection_threshold</span></code> is ignored.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">expandable_segments</span></code> (experimental, default: <cite>False</cite>) If set to <cite>True</cite>, this setting instructs
the allocator to create CUDA allocations that can later be expanded to better handle cases
where a job changing allocation sizes frequently, such as having a changing batch size.
Normally for large (&gt;2MB) allocations, the allocator calls cudaMalloc to get allocations
that are the same size as what the user requests. In the future, parts of these
allocations can be reused for other requests if they are free. This works well
when the program makes many requests of exactly the same size or of sizes that
even multiples of that size. Many deep learning models follow this behavior.
However, one common exception is when the batch size changes slightly from one
iteration to the next, e.g. in batched inference. When the program runs
initially with batch size <cite>N</cite>, it will make allocations appropriate for that size.
If in the future, it runs at size <cite>N - 1</cite>, the existing allocations will still be
big enough. However, if it runs at size <cite>N + 1</cite>, then it will have to make new
allocations that are slightly larger. Not all the tensors are the same size.
Some might be <cite>(N + 1)*A</cite> and others <cite>(N + 1)*A*B</cite> where <cite>A</cite> and <cite>B</cite> are some non-batch
dimensions in the model. Because the allocator reuses existing allocations when
they are big enough, some number of <cite>(N + 1)*A</cite> allocations will actually fit in
the already existing <cite>N*B*A</cite> segments, though not perfectly. As the model runs it
will partially fill up all of these segments leaving unusable free slices of
memory at the end of these segments. The allocator at some point will need to
<cite>cudaMalloc</cite> a new <cite>(N + 1)*A*B</cite> segment. If there is not enough memory, there is
now no way to recover the slices of memory that are free at the end of existing
segments. With models 50+ layers deep, this pattern might repeat 50+ times
creating many slivers.</p>
<p><cite>expandable_segments</cite> allows the allocator to create a segment initially and then
expand its size later when more memory is needed. Instead of making one segment
per allocation, it tries to make one segment (per stream) that grows as
necessary. Now when the <cite>N + 1</cite> case runs, the allocations will tile nicely into
the one large segment until it fills up. Then more memory is requested and
appended to the end of the segment. This process does not create as many slivers
of unusable memory, so it is more likely to succeed at finding this memory.</p>
</li>
<li><p><cite>pinned_use_cuda_host_register</cite> option is a boolean flag that determines whether to
use the CUDA APIs cudaHostRegister function for allocating pinned memory instead
of the default cudaHostAlloc. When set to True, the memory is allocated using regular
malloc and then pages are mapped to the memory before calling cudaHostRegister.
This pre-mapping of pages helps reduce the lock time during the execution
of cudaHostRegister.</p></li>
<li><p><cite>pinned_num_register_threads</cite> option is only valid when pinned_use_cuda_host_register
is set to True. By default, one thread is used to map the pages. This option allows
using more threads to parallelize the page mapping operations to reduce the overall
allocation time of pinned memory. A good value for this option is 8 based on
benchmarking results.</p></li>
<li><p><cite>pinned_use_background_threads</cite> option is a boolean flag to enable background thread
for processing events. This avoids any slow path associated with querying/processing of
events in the fast allocation path. This feature is disabled by default.</p></li>
<li><p><cite>pinned_reserve_segment_size_mb</cite> option is a size in MB to reserve for pinned memory
segment. This allocates a large segment of pinned memory upfront and then uses to allocate
small size requests. This helps reduce the number of expensive device library calls.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">graph_capture_record_stream_reuse</span></code> (experimental, default: <cite>False</cite>)
If set to <cite>True</cite>, the CUDA caching allocator will attempt to reclaim device memory during
CUDA Graph capture by using the graph topology (instead of CUDA events) to determine
when a freed block is safe to reuse. This can reduce peak memory during long captures that free
and reallocate buffers across multiple streams, especially when the capture DAG frequently
reaches joined frontiers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">per_process_memory_fraction</span></code> option limits the amount of memory that can be allocated
on all the CUDA devices to a specified fraction of the available memory. This is a value
between 0 and 1. Attempting to allocate more memory will raise an out of memory error.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some stats reported by the
<a class="reference internal" href="../cuda.html#cuda-memory-management-api"><span class="std std-ref">CUDA memory management API</span></a>
are specific to <code class="docutils literal notranslate"><span class="pre">backend:native</span></code>, and are not meaningful with
<code class="docutils literal notranslate"><span class="pre">backend:cudaMallocAsync</span></code>.
See each functions docstring for details.</p>
</div>
</section>
</section>
<section id="using-custom-memory-allocators-for-cuda">
<span id="cuda-memory-custom-allocator"></span><h2>Using custom memory allocators for CUDA<a class="headerlink" href="#using-custom-memory-allocators-for-cuda" title="Link to this heading">#</a></h2>
<p>It is possible to define allocators as simple functions in C/C++ and compile
them as a shared library, the code below shows a basic allocator that just
traces all the memory operations.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/types.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda_runtime_api.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="c1">// Compile with g++ alloc.cc -o alloc.so -I/usr/local/cuda/include -shared -fPIC</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">my_malloc</span><span class="p">(</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="w">   </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;alloc &quot;</span><span class="o">&lt;&lt;</span><span class="n">ptr</span><span class="o">&lt;&lt;</span><span class="n">size</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">my_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;free &quot;</span><span class="o">&lt;&lt;</span><span class="n">ptr</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="o">&lt;&lt;</span><span class="n">stream</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This can be used in python through the <a class="reference internal" href="../generated/torch.cuda.memory.CUDAPluggableAllocator.html#torch.cuda.memory.CUDAPluggableAllocator" title="torch.cuda.memory.CUDAPluggableAllocator"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.memory.CUDAPluggableAllocator</span></code></a>.
The user is responsible for supplying the path to the <cite>.so</cite> file and the name
of the alloc/free functions that match the signatures specified above.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># Load the allocator</span>
<span class="n">new_alloc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">CUDAPluggableAllocator</span><span class="p">(</span>
    <span class="s1">&#39;alloc.so&#39;</span><span class="p">,</span> <span class="s1">&#39;my_malloc&#39;</span><span class="p">,</span> <span class="s1">&#39;my_free&#39;</span><span class="p">)</span>
<span class="c1"># Swap the current allocator</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">change_current_allocator</span><span class="p">(</span><span class="n">new_alloc</span><span class="p">)</span>
<span class="c1"># This will allocate memory in the device using the new allocator</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># Do an initial memory allocator</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="c1"># Load the allocator</span>
<span class="n">new_alloc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">CUDAPluggableAllocator</span><span class="p">(</span>
    <span class="s1">&#39;alloc.so&#39;</span><span class="p">,</span> <span class="s1">&#39;my_malloc&#39;</span><span class="p">,</span> <span class="s1">&#39;my_free&#39;</span><span class="p">)</span>
<span class="c1"># This will error since the current allocator was already instantiated</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">change_current_allocator</span><span class="p">(</span><span class="n">new_alloc</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="mixing-different-cuda-system-allocators-in-the-same-program">
<h2>Mixing different CUDA system allocators in the same program<a class="headerlink" href="#mixing-different-cuda-system-allocators-in-the-same-program" title="Link to this heading">#</a></h2>
<p>Depending on your use case, <code class="xref py py-meth docutils literal notranslate"><span class="pre">change_current_allocator()</span></code> may not be what you
want to use, since it swaps the CUDA allocator for the entire program (similar to
<code class="docutils literal notranslate"><span class="pre">PYTORCH_ALLOC_CONF=backend:cudaMallocAsync</span></code>). For instance, if the swapped allocator doesnt
have caching mechanism, you will lose all the benefits of PyTorchs CUDACachingAllocator. Instead,
you can selectively mark a region of PyTorch code to use a custom allocator using
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.MemPool</span></code>. This will let you use multiple CUDA system allocators in the same
PyTorch program, along with most of the benefits of the CUDACachingAllocator (e.g. caching).
Using <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.MemPool</span></code>, you can utilize custom allocators that enable several features,
such as:</p>
<ul class="simple">
<li><p>Allocating output buffers for an all-reduce using <code class="docutils literal notranslate"><span class="pre">ncclMemAlloc</span></code> allocator can enable NVLink
Switch Reductions (NVLS). This can reduce contention between overlapping compute and communication
kernels on GPU resources (SMs, and Copy Engines), especially on tensor-parallel workloads.</p></li>
<li><p>For Grace CPU based systems, allocating host outputs buffers for an all-gather using <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code>
and specifying <code class="docutils literal notranslate"><span class="pre">CU_MEM_LOCATION_TYPE_HOST_NUMA</span></code> can enable Extended GPU Memory (EGM) based memory transfers
from source GPUs to the destination CPU. This accelerates the all-gather since the transfer
happens over NVLinks, which otherwise would have happened over bandwidth-limited, Network Interface
Card (NIC) links. Such an accelerated all-gather can in turn speed up model checkpointing.</p></li>
<li><p>If you are crafting a model and dont want to think about the optimal memory placements of a memory
intensive module at first (e.g. an embedding table), or perhaps you have a module which is not
performance sensitive and doesnt fit in the GPU, then you could just allocate that module with
<code class="docutils literal notranslate"><span class="pre">cudaMallocManaged</span></code> with preferred CPU location and get your model working first.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged</span></code> offers convenient automatic memory management using CUDA Unified Virtual Memory (UVM),
it is not recommended for DL workloads. For DL workloads that fit in GPU memory, explicit placement consistently
outperforms UVM, since there are no page faults and access patterns remain predictable. When GPU memory gets
saturated, UVM has to perform costly double transfers, evicting pages to CPU before bringing in new ones.</p>
</div>
<p>The code below shows <code class="docutils literal notranslate"><span class="pre">ncclMemAlloc</span></code> wrapped in a <a class="reference internal" href="../generated/torch.cuda.memory.CUDAPluggableAllocator.html#torch.cuda.memory.CUDAPluggableAllocator" title="torch.cuda.memory.CUDAPluggableAllocator"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.memory.CUDAPluggableAllocator</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.distributed</span> <span class="k">as</span> <span class="nn">dist</span>
<span class="kn">from</span> <span class="nn">torch.cuda.memory</span> <span class="kn">import</span> <span class="n">CUDAPluggableAllocator</span>
<span class="kn">from</span> <span class="nn">torch.distributed.distributed_c10d</span> <span class="kn">import</span> <span class="n">_get_default_group</span>
<span class="kn">from</span> <span class="nn">torch.utils</span> <span class="kn">import</span> <span class="n">cpp_extension</span>


<span class="c1"># create allocator</span>
<span class="n">nccl_allocator_source</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">#include &lt;nccl.h&gt;</span>
<span class="s2">#include &lt;iostream&gt;</span>
<span class="s2">extern &quot;C&quot; {</span>

<span class="s2">void* nccl_alloc_plug(size_t size, int device, void* stream) {</span>
<span class="s2">  std::cout &lt;&lt; &quot;Using ncclMemAlloc&quot; &lt;&lt; std::endl;</span>
<span class="s2">  void* ptr;</span>
<span class="s2">  ncclResult_t err = ncclMemAlloc(&amp;ptr, size);</span>
<span class="s2">  return ptr;</span>

<span class="s2">}</span>

<span class="s2">void nccl_free_plug(void* ptr, size_t size, int device, void* stream) {</span>
<span class="s2">  std::cout &lt;&lt; &quot;Using ncclMemFree&quot; &lt;&lt; std::endl;</span>
<span class="s2">  ncclResult_t err = ncclMemFree(ptr);</span>
<span class="s2">}</span>

<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">nccl_allocator_libname</span> <span class="o">=</span> <span class="s2">&quot;nccl_allocator&quot;</span>
<span class="n">nccl_allocator</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">cpp_extension</span><span class="o">.</span><span class="n">load_inline</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="n">nccl_allocator_libname</span><span class="p">,</span>
    <span class="n">cpp_sources</span><span class="o">=</span><span class="n">nccl_allocator_source</span><span class="p">,</span>
    <span class="n">with_cuda</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">extra_ldflags</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;-lnccl&quot;</span><span class="p">],</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">is_python_module</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">build_directory</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">allocator</span> <span class="o">=</span> <span class="n">CUDAPluggableAllocator</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;./</span><span class="si">{</span><span class="n">nccl_allocator_libname</span><span class="si">}</span><span class="s2">.so&quot;</span><span class="p">,</span> <span class="s2">&quot;nccl_alloc_plug&quot;</span><span class="p">,</span> <span class="s2">&quot;nccl_free_plug&quot;</span>
<span class="p">)</span><span class="o">.</span><span class="n">allocator</span><span class="p">()</span>

<span class="c1"># setup distributed</span>
<span class="n">rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;RANK&quot;</span><span class="p">))</span>
<span class="n">local_rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;LOCAL_RANK&quot;</span><span class="p">))</span>
<span class="n">world_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;WORLD_SIZE&quot;</span><span class="p">))</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">local_rank</span><span class="p">)</span>
<span class="n">dist</span><span class="o">.</span><span class="n">init_process_group</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;nccl&quot;</span><span class="p">)</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cuda:</span><span class="si">{</span><span class="n">local_rank</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">default_pg</span> <span class="o">=</span> <span class="n">_get_default_group</span><span class="p">()</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">default_pg</span><span class="o">.</span><span class="n">_get_backend</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="c1"># Note: for convenience, ProcessGroupNCCL backend provides</span>
<span class="c1"># the ncclMemAlloc allocator as backend.mem_allocator</span>
<span class="n">allocator</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">mem_allocator</span>
</pre></div>
</div>
<p>You can now define a new memory pool by passing this allocator to <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.MemPool</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pool</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">MemPool</span><span class="p">(</span><span class="n">allocator</span><span class="p">)</span>
</pre></div>
</div>
<p>The pool can then be used with the <a class="reference internal" href="../cuda.html#torch.cuda.use_mem_pool" title="torch.cuda.use_mem_pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.use_mem_pool</span></code></a> context manager to
allocate tensors into that pool:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">use_mem_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
    <span class="c1"># tensor gets allocated with ncclMemAlloc passed in the pool</span>
    <span class="n">tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tensor ptr on rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2"> is </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">data_ptr</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># register user buffers using ncclCommRegister (called under the hood)</span>
<span class="n">backend</span><span class="o">.</span><span class="n">register_mem_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>

<span class="c1"># Collective uses Zero Copy NVLS</span>
<span class="n">dist</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>Note the usage of <code class="docutils literal notranslate"><span class="pre">register_mem_pool</span></code> in the above example. This is an extra step for
NVLS reductions, where the user buffers need to be registered with NCCL. A user can
de-register the buffers with a similar <code class="docutils literal notranslate"><span class="pre">deregister_mem_pool</span></code> call.</p>
<p>To reclaim memory, users will first need to ensure nothing is using the pool. When none
of the tensors are holding a reference to the pool, <code class="xref py py-meth docutils literal notranslate"><span class="pre">empty_cache()</span></code> will
be called internally on deletion of the pool, hence returning all the memory to the system.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">tensor</span><span class="p">,</span> <span class="k">del</span> <span class="n">pool</span>
</pre></div>
</div>
<p>Users can optionally specify a <code class="docutils literal notranslate"><span class="pre">use_on_oom</span></code> bool (which is False by default) during MemPool
creation. If true, then the CUDACachingAllocator will be able to use memory in this pool as
a last resort instead of OOMing.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pool</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">MemPool</span><span class="p">(</span><span class="n">allocator</span><span class="p">,</span> <span class="n">use_on_oom</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">use_mem_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">40</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
<span class="k">del</span> <span class="n">a</span>

<span class="c1"># at the memory limit, this will succeed by using pool&#39;s memory in order to avoid the oom</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">40</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The following <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.cuda.MemPool.use_count()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.cuda.MemPool.snapshot()</span></code>
APIs can be used for debugging purposes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pool</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">MemPool</span><span class="p">(</span><span class="n">allocator</span><span class="p">)</span>

<span class="c1"># pool&#39;s use count should be 1 at this point as MemPool object</span>
<span class="c1"># holds a reference</span>
<span class="k">assert</span> <span class="n">pool</span><span class="o">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>

<span class="n">nelem_1mb</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">//</span> <span class="mi">4</span>

<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">use_mem_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
    <span class="n">out_0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nelem_1mb</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>

    <span class="c1"># pool&#39;s use count should be 2 at this point as use_mem_pool</span>
    <span class="c1"># holds a reference</span>
    <span class="k">assert</span> <span class="n">pool</span><span class="o">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span>

<span class="c1"># pool&#39;s use count should be back to 1 at this point as use_mem_pool</span>
<span class="c1"># released its reference</span>
<span class="k">assert</span> <span class="n">pool</span><span class="o">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>

<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">use_mem_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">):</span>
    <span class="c1"># pool should have 1 segment since we made a small allocation (1 MB)</span>
    <span class="c1"># above and so the CUDACachingAllocator packed it into a 2 MB buffer</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">snapshot</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">out_1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nelem_1mb</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>

    <span class="c1"># pool should still have 1 segment since we made another small allocation</span>
    <span class="c1"># (1 MB) that got packed into the existing 2 MB buffer</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">snapshot</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">out_2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nelem_1mb</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>

    <span class="c1"># pool now should have 2 segments since the CUDACachingAllocator had</span>
    <span class="c1"># to make a new 2 MB buffer to accommodate out_2</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">snapshot</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.MemPool</span></code> holds a reference to the pool. When you use the
<a class="reference internal" href="../cuda.html#torch.cuda.use_mem_pool" title="torch.cuda.use_mem_pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.use_mem_pool</span></code></a> context manager, it will also acquire another reference
to the pool. On exit of the context manager, it will release its reference. After that,
ideally it should only be tensors holding references to the pool. Once the tensors release
their references, the use count of the pool will be 1, reflecting that only the
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.MemPool</span></code> object is holding a reference. Only at that point, can the memory
held by the pool be returned to the system when the pools destructor is called using
<code class="docutils literal notranslate"><span class="pre">del</span></code>.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.MemPool</span></code> doesnt currently support <code class="docutils literal notranslate"><span class="pre">expandable_segments</span></code> mode of
CUDACachingAllocator.</p></li>
<li><p><a class="reference external" href="https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/bufferreg.html#memory-allocator">NCCL has specific requirements</a> for a buffer to be compatible with NVLS reductions.
These requirements can be broken in a dynamic workload, for instance, the buffer being
sent to NCCL by the CUDACachingAllocator might be split and hence, not correctly aligned.
In those cases, NCCL can use a fallback algorithm instead of NVLS.</p></li>
<li><p>Allocators like <code class="docutils literal notranslate"><span class="pre">ncclMemAlloc</span></code> can use more memory than requested, due to alignment
requirements (<code class="docutils literal notranslate"><span class="pre">CU_MULTICAST_GRANULARITY_RECOMMENDED</span></code>, <code class="docutils literal notranslate"><span class="pre">CU_MULTICAST_GRANULARITY_MINIMUM</span></code>),
and can cause your workload to run out of memory.</p></li>
</ul>
</div>
</section>
<section id="tuning-nvlink-performance-with-custom-memory-allocator-on-h100-h200-gpus">
<h2>Tuning NVLink Performance with Custom Memory Allocator on H100/H200 GPUs<a class="headerlink" href="#tuning-nvlink-performance-with-custom-memory-allocator-on-h100-h200-gpus" title="Link to this heading">#</a></h2>
<p>In rare cases, performance of NVLink on H100/H200 GPUs can be influenced by the physical memory
layout of data, creating an opportunity for developers to tune their applications for optimal
throughput.</p>
<p>An example of how physical memory layout of data affects performance is when communication
kernels issue unbalanced NVLink read/write operations. In the following figure, we can see
that each warp accesses memory addresses with a consistent strided pattern in each single wave.
We can have a more balanced load by tuning the stride size in the workload or we can implement
a custom CUDA allocator.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_______________________________</span>  <span class="n">_______________________________</span>      <span class="n">_______________________________</span>
<span class="o">|</span> <span class="n">Warp</span> <span class="mi">0</span> <span class="n">Reading</span> <span class="o">|</span> <span class="n">No</span><span class="o">-</span><span class="n">reading</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Warp</span> <span class="mi">1</span> <span class="n">Reading</span> <span class="o">|</span> <span class="n">No</span><span class="o">-</span><span class="n">reading</span> <span class="o">|</span>  <span class="o">...</span>  <span class="n">Warp</span> <span class="n">N</span> <span class="n">Reading</span> <span class="o">|</span> <span class="n">No</span><span class="o">-</span><span class="n">reading</span> <span class="o">|</span>
<span class="n">_______________________________</span>  <span class="n">_______________________________</span>      <span class="n">_______________________________</span>
<span class="o">&lt;-----------------------------&gt;</span>
        <span class="n">Stride</span> <span class="n">size</span>
</pre></div>
</div>
<p>Such an allocator can maintain contiguous virtual memory addresses for the kernel while strategically
arranging the mapping to physical memory addresses (e.g., through shuffling). This technique allows
developers to explore different physical access patterns to find the most efficient one, unlocking
higher performance without modifying the kernels logic. A practical implementation of such an allocator
can be achieved using PyTorchs custom allocator support as mentioned before, where the malloc and free
functions are:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// assuming a system with 8 GPUs</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">CustomAllocInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="o">**</span><span class="w"> </span><span class="n">devPtr</span><span class="p">;</span><span class="w">  </span><span class="c1">// This will be the usable virtual memory address</span>
<span class="w">  </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dptr</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">totalSize</span><span class="p">;</span><span class="w">  </span><span class="c1">// Total size of the allocated memory</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">padded_size</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">device_id</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CUmemGenericAllocationHandle</span><span class="o">&gt;</span><span class="w"> </span><span class="n">handles</span><span class="p">;</span><span class="w">  </span><span class="c1">// Handles to physical memory allocations</span>
<span class="p">};</span>

<span class="c1">// loop over pages</span>
<span class="n">cudaError_t</span><span class="w"> </span><span class="nf">customCudaMalloc</span><span class="p">(</span><span class="n">CustomAllocInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">cudaErrorInvalidValue</span><span class="p">;</span>

<span class="w">    </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dptr</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Handles to redundant physical memory allocations which help truncate stride pattern in physical memory</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CUmemGenericAllocationHandle</span><span class="o">&gt;</span><span class="w"> </span><span class="n">handles_redundant</span><span class="p">;</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">granularity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">CUmemAllocationProp</span><span class="w"> </span><span class="n">prop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">currentDev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">totalSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">totalSize</span><span class="p">;</span>

<span class="w">    </span><span class="n">prop</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_ALLOCATION_TYPE_PINNED</span><span class="p">;</span>
<span class="w">    </span><span class="n">prop</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_LOCATION_TYPE_DEVICE</span><span class="p">;</span>
<span class="w">    </span><span class="n">prop</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentDev</span><span class="p">;</span>
<span class="w">    </span><span class="n">cuMemGetAllocationGranularity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">granularity</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="n">CU_MEM_ALLOC_GRANULARITY_MINIMUM</span><span class="p">);</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">padded_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ROUND_UP</span><span class="p">(</span><span class="n">totalSize</span><span class="p">,</span><span class="w"> </span><span class="n">granularity</span><span class="p">);</span>

<span class="w">    </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">padded_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">padded_size</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// loop over pages</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">iter_granularity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">granularity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w"> </span><span class="c1">// 64 * granularity with shift_size = 2 works</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iteration_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">totalSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">iter_granularity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">iter_granularity</span><span class="p">;</span>

<span class="w">    </span><span class="n">cuMemAddressReserve</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">padded_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0ULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0ULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0ULL</span><span class="p">);</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iteration_count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="n">shift_size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="n">CUmemGenericAllocationHandle</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">[</span><span class="n">shift_size</span><span class="p">];</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shift_size</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">shift</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iteration_count</span><span class="p">);</span><span class="w"> </span><span class="n">shift</span><span class="o">++</span><span class="p">){</span>
<span class="w">            </span><span class="n">CHECK_CUDA</span><span class="p">(</span><span class="n">cuMemCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">allocHandle</span><span class="p">[</span><span class="n">shift</span><span class="p">],</span><span class="w"> </span><span class="n">iter_granularity</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w">            </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">handles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">allocHandle</span><span class="p">[</span><span class="n">shift</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shift_size</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">shift</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iteration_count</span><span class="p">);</span><span class="w"> </span><span class="n">shift</span><span class="o">++</span><span class="p">){</span>

<span class="w">            </span><span class="c1">// mapping makes the shift (shift -&gt; (shift+1)%shift_size  )</span>
<span class="w">            </span><span class="n">CHECK_CUDA</span><span class="p">(</span><span class="n">cuMemMap</span><span class="p">(</span><span class="n">dptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">shift</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter_granularity</span><span class="p">,</span><span class="w"> </span><span class="n">iter_granularity</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">[(</span><span class="n">shift</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">shift_size</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="w">            </span><span class="n">setupMultiGPUAccess</span><span class="p">(</span><span class="n">dptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">shift</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter_granularity</span><span class="p">,</span><span class="w"> </span><span class="n">iter_granularity</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">});</span><span class="w"> </span><span class="c1">// Enable access for all 8 GPUs</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// std::cout &lt;&lt; &quot;Here we allocate one redundant page (2MB)...&quot; &lt;&lt; std::endl;</span>
<span class="w">        </span><span class="c1">// this is an extra optimization on top of the swizzling. It helps &quot;break&quot;</span>
<span class="w">        </span><span class="c1">// the physical access pattern even more. It can be left out if workload is already</span>
<span class="w">        </span><span class="c1">// performing at SOL with just swizzling.</span>
<span class="w">        </span><span class="n">CUmemGenericAllocationHandle</span><span class="w"> </span><span class="n">allocHandle_redundant</span><span class="p">;</span>
<span class="w">        </span><span class="n">CHECK_CUDA</span><span class="p">(</span><span class="n">cuMemCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">allocHandle_redundant</span><span class="p">,</span><span class="w"> </span><span class="n">granularity</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w">        </span><span class="n">handles_redundant</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">allocHandle_redundant</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">devPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">dptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dptr</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Release each redundant allocation</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">handles_redundant</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// std::cout &lt;&lt; &quot;Here we release one redundant page (2MB)...&quot; &lt;&lt; std::endl;</span>
<span class="w">        </span><span class="n">CHECK_CUDA</span><span class="p">(</span><span class="n">cuMemRelease</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">customCudaFree</span><span class="p">(</span><span class="n">CustomAllocInfo</span><span class="o">*</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// CHECK_CUDA(cudaSetDevice(info-&gt;device_id));</span>

<span class="w">    </span><span class="n">CHECK_CUDA</span><span class="p">(</span><span class="n">cuMemUnmap</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">padded_size</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// Unmap and release each allocation</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">handles</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">CHECK_CUDA</span><span class="p">(</span><span class="n">cuMemRelease</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Unreserve the virtual address space</span>
<span class="w">    </span><span class="c1">// CHECK_CUDA(cuMemAddressFree((CUdeviceptr)*info-&gt;devPtr, info-&gt;padded_size));</span>
<span class="w">    </span><span class="n">CHECK_CUDA</span><span class="p">(</span><span class="n">cuMemAddressFree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">padded_size</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="cublas-workspaces">
<h2>cuBLAS workspaces<a class="headerlink" href="#cublas-workspaces" title="Link to this heading">#</a></h2>
<p>For each combination of cuBLAS handle and CUDA stream, a cuBLAS workspace will be allocated
if that handle and stream combination executes a cuBLAS kernel that requires a workspace.
In order to avoid repeatedly allocating workspaces, these workspaces are not deallocated unless
<code class="docutils literal notranslate"><span class="pre">torch._C._cuda_clearCublasWorkspaces()</span></code> is called. The workspace size per allocation can be
specified via the environment variable <code class="docutils literal notranslate"><span class="pre">CUBLAS_WORKSPACE_CONFIG</span></code> with the format <code class="docutils literal notranslate"><span class="pre">:[SIZE]:[COUNT]</span></code>.
As an example, the default workspace size per allocation is <code class="docutils literal notranslate"><span class="pre">CUBLAS_WORKSPACE_CONFIG=:4096:2:16:8</span></code>
which specifies a total size of <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4096</span> <span class="pre">+</span> <span class="pre">8</span> <span class="pre">*</span> <span class="pre">16</span> <span class="pre">KiB</span></code>. To force cuBLAS to avoid using workspaces,
set <code class="docutils literal notranslate"><span class="pre">CUBLAS_WORKSPACE_CONFIG=:0:0</span></code>.</p>
</section>
<section id="cufft-plan-cache">
<span id="id2"></span><h2>cuFFT plan cache<a class="headerlink" href="#cufft-plan-cache" title="Link to this heading">#</a></h2>
<p>For each CUDA device, an LRU cache of cuFFT plans is used to speed up repeatedly
running FFT methods (e.g., <a class="reference internal" href="../generated/torch.fft.fft.html#torch.fft.fft" title="torch.fft.fft"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.fft.fft()</span></code></a>) on CUDA tensors of same geometry
with same configuration. Because some cuFFT plans may allocate GPU memory,
these caches have a maximum capacity.</p>
<p>You may control and query the properties of the cache of current device with
the following APIs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache.max_size</span></code> gives the capacity of the
cache (default is 4096 on CUDA 10 and newer, and 1023 on older CUDA versions).
Setting this value directly modifies the capacity.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache.size</span></code> gives the number of plans
currently residing in the cache.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache.clear()</span></code> clears the cache.</p></li>
</ul>
<p>To control and query plan caches of a non-default device, you can index the
<code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache</span></code> object with either a <a class="reference internal" href="../tensor_attributes.html#torch.device" title="torch.device"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code></a>
object or a device index, and access one of the above attributes. E.g., to set
the capacity of the cache for device <code class="docutils literal notranslate"><span class="pre">1</span></code>, one can write
<code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache[1].max_size</span> <span class="pre">=</span> <span class="pre">10</span></code>.</p>
</section>
<section id="just-in-time-compilation">
<span id="cuda-just-in-time-compilation"></span><h2>Just-in-Time Compilation<a class="headerlink" href="#just-in-time-compilation" title="Link to this heading">#</a></h2>
<p>PyTorch just-in-time compiles some operations, like torch.special.zeta, when
performed on CUDA tensors. This compilation can be time consuming
(up to a few seconds depending on your hardware and software)
and may occur multiple times for a single operator since many PyTorch operators actually
select from a variety of kernels, each of which must be compiled once, depending on their input.
This compilation occurs once per process, or just once if a kernel cache is used.</p>
<p>By default, PyTorch creates a kernel cache in $XDG_CACHE_HOME/torch/kernels if
XDG_CACHE_HOME is defined and $HOME/.cache/torch/kernels if its not (except on Windows,
where the kernel cache is not yet supported). The caching behavior can be directly
controlled with two environment variables. If USE_PYTORCH_KERNEL_CACHE is set to 0 then no
cache will be used, and if PYTORCH_KERNEL_CACHE_PATH is set then that path will be used
as a kernel cache instead of the default location.</p>
</section>
<section id="best-practices">
<h2>Best practices<a class="headerlink" href="#best-practices" title="Link to this heading">#</a></h2>
<section id="device-agnostic-code">
<h3>Device-agnostic code<a class="headerlink" href="#device-agnostic-code" title="Link to this heading">#</a></h3>
<p>Due to the structure of PyTorch, you may need to explicitly write
device-agnostic (CPU or GPU) code; an example may be creating a new tensor as
the initial hidden state of a recurrent neural network.</p>
<p>The first step is to determine whether the GPU should be used or not. A common
pattern is to use Pythons <code class="docutils literal notranslate"><span class="pre">argparse</span></code> module to read in user arguments, and
have a flag that can be used to disable CUDA, in combination with
<a class="reference internal" href="../generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a>. In the following, <code class="docutils literal notranslate"><span class="pre">args.device</span></code> results in a
<a class="reference internal" href="../tensor_attributes.html#torch.device" title="torch.device"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code></a> object that can be used to move tensors to CPU or CUDA.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;PyTorch Example&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--disable-cuda&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Disable CUDA&#39;</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="n">args</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">disable_cuda</span> <span class="ow">and</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
    <span class="n">args</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">args</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When assessing the availability of CUDA in a given environment (<a class="reference internal" href="../generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a>), PyTorchs default
behavior is to call the CUDA Runtime API method <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g18808e54893cfcaafefeab31a73cc55f">cudaGetDeviceCount</a>. Because this call in turn initializes the
CUDA Driver API (via <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__INITIALIZE.html#group__CUDA__INITIALIZE_1g0a2f1517e1bd8502c7194c3a8c134bc3">cuInit</a>) if it is not already initialized, subsequent forks of a process that has run
<a class="reference internal" href="../generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> will fail with a CUDA initialization error.</p>
<p>One can set <code class="docutils literal notranslate"><span class="pre">PYTORCH_NVML_BASED_CUDA_CHECK=1</span></code> in your environment before importing PyTorch modules that execute
<a class="reference internal" href="../generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> (or before executing it directly) in order to direct
<a class="reference internal" href="../generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> to attempt an NVML-based assessment (<a class="reference external" href="https://docs.nvidia.com/deploy/nvml-api/group__nvmlDeviceQueries.html#group__nvmlDeviceQueries_1ga93623b195bff04bbe3490ca33c8a42d">nvmlDeviceGetCount_v2</a>). If the
NVML-based assessment is successful (i.e. NVML discovery/initialization does not fail),
<a class="reference internal" href="../generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> calls will not poison subsequent forks.</p>
<p>If NVML discovery/initialization fails, <a class="reference internal" href="../generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> will fallback to the standard CUDA Runtime
API assessment and the aforementioned fork constraint will apply.</p>
<p>Note that the above NVML-based CUDA availability assessment provides a weaker guarantee than the default CUDA
Runtime API approach (which requires CUDA initialization to succeed). In some circumstances, the NVML-based check
may succeed while later CUDA initialization fails.</p>
</div>
<p>Now that we have <code class="docutils literal notranslate"><span class="pre">args.device</span></code>, we can use it to create a Tensor on the
desired device.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span> <span class="mi">42</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
<p>This can be used in a number of cases to produce device agnostic code. Below
is an example when using a dataloader:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda:0&#39;</span><span class="p">)</span>  <span class="c1"># CUDA GPU 0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">train_loader</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">cuda0</span><span class="p">)</span>
</pre></div>
</div>
<p>When working with multiple GPUs on a system, you can use the
<code class="docutils literal notranslate"><span class="pre">CUDA_VISIBLE_DEVICES</span></code> environment flag to manage which GPUs are available to
PyTorch. As mentioned above, to manually control which GPU a tensor is created
on, the best practice is to use a <a class="reference internal" href="../generated/torch.cuda.device.html#torch.cuda.device" title="torch.cuda.device"><code class="xref any py py-class docutils literal notranslate"><span class="pre">torch.cuda.device</span></code></a> context manager.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Outside device is 0&quot;</span><span class="p">)</span>  <span class="c1"># On device 0 (default in most scenarios)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inside device is 1&quot;</span><span class="p">)</span>  <span class="c1"># On device 1</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Outside device is still 0&quot;</span><span class="p">)</span>  <span class="c1"># On device 0</span>
</pre></div>
</div>
<p>If you have a tensor and would like to create a new tensor of the same type on
the same device, then you can use a <code class="docutils literal notranslate"><span class="pre">torch.Tensor.new_*</span></code> method
(see <a class="reference internal" href="../tensors.html#torch.Tensor" title="torch.Tensor"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>).
Whilst the previously mentioned <code class="docutils literal notranslate"><span class="pre">torch.*</span></code> factory functions
(<a class="reference internal" href="../torch.html#tensor-creation-ops"><span class="std std-ref">Creation Ops</span></a>) depend on the current GPU context and
the attributes arguments you pass in, <code class="docutils literal notranslate"><span class="pre">torch.Tensor.new_*</span></code> methods preserve
the device and other attributes of the tensor.</p>
<p>This is the recommended practice when creating modules in which new
tensors need to be created internally during the forward pass.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">x_cpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">x_gpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span>
<span class="n">x_cpu_long</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

<span class="n">y_cpu</span> <span class="o">=</span> <span class="n">x_cpu</span><span class="o">.</span><span class="n">new_full</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y_cpu</span><span class="p">)</span>

    <span class="n">tensor</span><span class="p">([[</span> <span class="mf">0.3000</span><span class="p">,</span>  <span class="mf">0.3000</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.3000</span><span class="p">,</span>  <span class="mf">0.3000</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.3000</span><span class="p">,</span>  <span class="mf">0.3000</span><span class="p">]])</span>

<span class="n">y_gpu</span> <span class="o">=</span> <span class="n">x_gpu</span><span class="o">.</span><span class="n">new_full</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y_gpu</span><span class="p">)</span>

    <span class="n">tensor</span><span class="p">([[</span><span class="o">-</span><span class="mf">5.0000</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0000</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">5.0000</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0000</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">5.0000</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0000</span><span class="p">]],</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda:0&#39;</span><span class="p">)</span>

<span class="n">y_cpu_long</span> <span class="o">=</span> <span class="n">x_cpu_long</span><span class="o">.</span><span class="n">new_tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y_cpu_long</span><span class="p">)</span>

    <span class="n">tensor</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">]])</span>
</pre></div>
</div>
<p>If you want to create a tensor of the same type and size of another tensor, and
fill it with either ones or zeros, <a class="reference internal" href="../generated/torch.ones_like.html#torch.ones_like" title="torch.ones_like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ones_like()</span></code></a> or
<a class="reference internal" href="../generated/torch.zeros_like.html#torch.zeros_like" title="torch.zeros_like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zeros_like()</span></code></a> are provided as convenient helper functions (which
also preserve <a class="reference internal" href="../tensor_attributes.html#torch.device" title="torch.device"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code></a> and <a class="reference internal" href="../tensor_attributes.html#torch.dtype" title="torch.dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code></a> of a Tensor).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_cpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">x_gpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">y_cpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x_cpu</span><span class="p">)</span>
<span class="n">y_gpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x_gpu</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="use-pinned-memory-buffers">
<span id="cuda-memory-pinning"></span><h3>Use pinned memory buffers<a class="headerlink" href="#use-pinned-memory-buffers" title="Link to this heading">#</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an advanced tip. If you overuse pinned memory, it can cause serious
problems when running low on RAM, and you should be aware that pinning is
often an expensive operation.</p>
</div>
<p>Host to GPU copies are much faster when they originate from pinned (page-locked)
memory. CPU tensors and storages expose a <a class="reference internal" href="../generated/torch.Tensor.pin_memory.html#torch.Tensor.pin_memory" title="torch.Tensor.pin_memory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pin_memory()</span></code></a>
method, that returns a copy of the object, with data put in a pinned region.</p>
<p>Also, once you pin a tensor or storage, you can use asynchronous GPU copies.
Just pass an additional <code class="docutils literal notranslate"><span class="pre">non_blocking=True</span></code> argument to a
<a class="reference internal" href="../generated/torch.Tensor.to.html#torch.Tensor.to" title="torch.Tensor.to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to()</span></code></a> or a <a class="reference internal" href="../generated/torch.Tensor.cuda.html#torch.Tensor.cuda" title="torch.Tensor.cuda"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cuda()</span></code></a> call. This can be used
to overlap data transfers with computation.</p>
<p>You can make the <a class="reference internal" href="../data.html#torch.utils.data.DataLoader" title="torch.utils.data.DataLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code></a> return batches placed in
pinned memory by passing <code class="docutils literal notranslate"><span class="pre">pin_memory=True</span></code> to its constructor.</p>
</section>
<section id="use-nn-parallel-distributeddataparallel-instead-of-multiprocessing-or-nn-dataparallel">
<span id="cuda-nn-ddp-instead"></span><h3>Use nn.parallel.DistributedDataParallel instead of multiprocessing or nn.DataParallel<a class="headerlink" href="#use-nn-parallel-distributeddataparallel-instead-of-multiprocessing-or-nn-dataparallel" title="Link to this heading">#</a></h3>
<p>Most use cases involving batched inputs and multiple GPUs should default to
using <a class="reference internal" href="../generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a> to utilize more
than one GPU.</p>
<p>There are significant caveats to using CUDA models with
<a class="reference internal" href="../multiprocessing.html#module-torch.multiprocessing" title="torch.multiprocessing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>; unless care is taken to meet the data handling
requirements exactly, it is likely that your program will have incorrect or
undefined behavior.</p>
<p>It is recommended to use <a class="reference internal" href="../generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a>,
instead of <a class="reference internal" href="../generated/torch.nn.DataParallel.html#torch.nn.DataParallel" title="torch.nn.DataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataParallel</span></code></a> to do multi-GPU training, even if
there is only a single node.</p>
<p>The difference between <a class="reference internal" href="../generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a> and
<a class="reference internal" href="../generated/torch.nn.DataParallel.html#torch.nn.DataParallel" title="torch.nn.DataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataParallel</span></code></a> is: <a class="reference internal" href="../generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a>
uses multiprocessing where a process is created for each GPU, while
<a class="reference internal" href="../generated/torch.nn.DataParallel.html#torch.nn.DataParallel" title="torch.nn.DataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataParallel</span></code></a> uses multithreading. By using multiprocessing,
each GPU has its dedicated process, this avoids the performance overhead caused
by GIL of Python interpreter.</p>
<p>If you use <a class="reference internal" href="../generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a>, you could use
<cite>torch.distributed.launch</cite> utility to launch your program, see <a class="reference internal" href="../distributed.html#distributed-launch"><span class="std std-ref">Launch utility</span></a>.</p>
</section>
</section>
<section id="cuda-graphs">
<span id="cuda-graph-semantics"></span><h2>CUDA Graphs<a class="headerlink" href="#cuda-graphs" title="Link to this heading">#</a></h2>
<p>A CUDA graph is a record of the work (mostly kernels and their arguments) that a
CUDA stream and its dependent streams perform.
For general principles and details on the underlying CUDA API, see
<a class="reference external" href="https://developer.nvidia.com/blog/cuda-graphs/">Getting Started with CUDA Graphs</a> and the
<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-graphs">Graphs section</a> of the CUDA C Programming Guide.</p>
<p>PyTorch supports the construction of CUDA graphs using <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#creating-a-graph-using-stream-capture">stream capture</a>, which puts a
CUDA stream in <em>capture mode</em>. CUDA work issued to a capturing stream doesnt actually
run on the GPU. Instead, the work is recorded in a graph.</p>
<p>After capture, the graph can be <em>launched</em> to run the GPU work as many times as needed.
Each replay runs the same kernels with the same arguments. For pointer arguments this
means the same memory addresses are used.
By filling input memory with new data (e.g., from a new batch) before each replay,
you can rerun the same work on new data.</p>
<section id="why-cuda-graphs">
<h3>Why CUDA Graphs?<a class="headerlink" href="#why-cuda-graphs" title="Link to this heading">#</a></h3>
<p>Replaying a graph sacrifices the dynamic flexibility of typical eager execution in exchange for
<strong>greatly reduced CPU overhead</strong>. A graphs arguments and kernels are fixed, so a graph replay
skips all layers of argument setup and kernel dispatch, including Python, C++, and CUDA driver
overheads. Under the hood, a replay submits the entire graphs work to the GPU with
a single call to <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g1accfe1da0c605a577c22d9751a09597">cudaGraphLaunch</a>.  Kernels in a replay also execute slightly faster
on the GPU, but eliding CPU overhead is the main benefit.</p>
<p>You should try CUDA graphs if all or part of your network is graph-safe (usually this means
static shapes and static control flow, but see the other <a class="reference internal" href="#capture-constraints"><span class="std std-ref">constraints</span></a>)
and you suspect its runtime is at least somewhat CPU-limited.</p>
</section>
<section id="pytorch-api">
<h3>PyTorch API<a class="headerlink" href="#pytorch-api" title="Link to this heading">#</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is in beta and may change in future releases.</p>
</div>
<p>PyTorch exposes graphs via a raw <a class="reference internal" href="../generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph" title="torch.cuda.CUDAGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.CUDAGraph</span></code></a> class
and two convenience wrappers,
<a class="reference internal" href="../generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a> and
<a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables</span></code></a>.</p>
<p><a class="reference internal" href="../generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a> is a simple, versatile context manager that
captures CUDA work in its context.
Before capture, warm up the workload to be captured by running
a few eager iterations. Warmup must occur on a side stream.
Because the graph reads from and writes to the same memory addresses in every
replay, you must maintain long-lived references to tensors that hold
input and output data during capture.
To run the graph on new input data, copy new data to the captures input tensor(s),
replay the graph, then read the new output from the captures output tensor(s).
Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>

<span class="c1"># Placeholder input used for capture</span>
<span class="n">static_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>

<span class="c1"># Warmup before capture</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">static_output</span> <span class="o">=</span> <span class="n">static_input</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># Captures the graph</span>
<span class="c1"># To allow capture, automatically sets a side stream as the current stream in the context</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="n">static_output</span> <span class="o">=</span> <span class="n">static_input</span> <span class="o">*</span> <span class="mi">2</span>

<span class="c1"># Fills the graph&#39;s input memory with new data to compute on</span>
<span class="n">static_input</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">))</span>
<span class="n">g</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
<span class="c1"># static_output holds the results</span>
<span class="nb">print</span><span class="p">(</span><span class="n">static_output</span><span class="p">)</span>  <span class="c1"># full of 3 * 2 = 6</span>

<span class="c1"># Fills the graph&#39;s input memory with more data to compute on</span>
<span class="n">static_input</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">))</span>
<span class="n">g</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">static_output</span><span class="p">)</span>  <span class="c1"># full of 4 * 2 = 8</span>
</pre></div>
</div>
<p>See
<a class="reference internal" href="#whole-network-capture"><span class="std std-ref">Whole-network capture</span></a>,
<a class="reference internal" href="#graphs-with-amp"><span class="std std-ref">Usage with torch.cuda.amp</span></a>, and
<a class="reference internal" href="#multistream-capture"><span class="std std-ref">Usage with multiple streams</span></a>
for realistic and advanced patterns.</p>
<p><a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-class docutils literal notranslate"><span class="pre">make_graphed_callables</span></code></a> is more sophisticated.
<a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-class docutils literal notranslate"><span class="pre">make_graphed_callables</span></code></a> accepts Python functions and
<a class="reference internal" href="../generated/torch.nn.Module.html#torch.nn.Module" title="torch.nn.Module"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code></a>s. For each passed function or Module,
it creates separate graphs of the forward-pass and backward-pass work. See
<a class="reference internal" href="#partial-network-capture"><span class="std std-ref">Partial-network capture</span></a>.</p>
<section id="constraints">
<span id="capture-constraints"></span><h4>Constraints<a class="headerlink" href="#constraints" title="Link to this heading">#</a></h4>
<p>A set of ops is <em>capturable</em> if it doesnt violate any of the following constraints.</p>
<p>Constraints apply to all work in a
<a class="reference internal" href="../generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a> context and all work in the forward and backward passes
of any callable you pass to <a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables()</span></code></a>.</p>
<p>Violating any of these will likely cause a runtime error:</p>
<ul class="simple">
<li><p>Capture must occur on a non-default stream. (This is only a concern if you use the raw
<a class="reference internal" href="../generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph.capture_begin" title="torch.cuda.CUDAGraph.capture_begin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CUDAGraph.capture_begin</span></code></a> and
<a class="reference internal" href="../generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph.capture_end" title="torch.cuda.CUDAGraph.capture_end"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CUDAGraph.capture_end</span></code></a> calls.
<a class="reference internal" href="../generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph</span></code></a> and
<a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> set a side stream for you.)</p></li>
<li><p>Ops that synchronize the CPU with the GPU (e.g., <code class="docutils literal notranslate"><span class="pre">.item()</span></code> calls) are prohibited.</p></li>
<li><p>CUDA RNG operations are permitted, and when using multiple <a class="reference internal" href="../generated/torch.Generator.html#torch.Generator" title="torch.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Generator</span></code></a> instances within a graph,
they must be registered using <code class="xref py py-meth docutils literal notranslate"><span class="pre">CUDAGraph.register_generator_state</span></code> before graph capture.
Avoid using <code class="xref py py-meth docutils literal notranslate"><span class="pre">Generator.get_state</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Generator.set_state</span></code> during capture;
instead, utilize <a class="reference internal" href="../generated/torch.Generator.html#torch.Generator.graphsafe_set_state" title="torch.Generator.graphsafe_set_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Generator.graphsafe_set_state</span></code></a> and <a class="reference internal" href="../generated/torch.Generator.html#torch.Generator.graphsafe_get_state" title="torch.Generator.graphsafe_get_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Generator.graphsafe_get_state</span></code></a>
for managing generator states safely within the graph context. This ensures proper RNG operation and generator management within CUDA graphs.</p></li>
</ul>
<p>Violating any of these will likely cause silent numerical errors or undefined behavior:</p>
<ul class="simple">
<li><p>Within a process, only one capture may be underway at a time.</p></li>
<li><p>No non-captured CUDA work may run in this process (on any thread) while capture is underway.</p></li>
<li><p>CPU work is not captured. If the captured ops include CPU work, that work will be elided during replay.</p></li>
<li><p>Every replay reads from and writes to the same (virtual) memory addresses.</p></li>
<li><p>Dynamic control flow (based on CPU or GPU data) is prohibited.</p></li>
<li><p>Dynamic shapes are prohibited. The graph assumes every tensor in the captured op sequence
has the same size and layout in every replay.</p></li>
<li><p>Using multiple streams in a capture is allowed, but there are <a class="reference internal" href="#multistream-capture"><span class="std std-ref">restrictions</span></a>.</p></li>
</ul>
</section>
<section id="non-constraints">
<h4>Non-constraints<a class="headerlink" href="#non-constraints" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Once captured, the graph may be replayed on any stream.</p></li>
</ul>
</section>
</section>
<section id="whole-network-capture">
<span id="id3"></span><h3>Whole-network capture<a class="headerlink" href="#whole-network-capture" title="Link to this heading">#</a></h3>
<p>If your entire network is capturable, you can capture and replay an entire iteration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">D_in</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">D_out</span> <span class="o">=</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">1024</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">D_in</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span>
                            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">),</span>
                            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">D_out</span><span class="p">),</span>
                            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.1</span><span class="p">))</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Placeholders used for capture</span>
<span class="n">static_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D_in</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">static_target</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D_out</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>

<span class="c1"># warmup</span>
<span class="c1"># Uses static_input and static_target here for convenience,</span>
<span class="c1"># but in a real setting, because the warmup includes optimizer.step()</span>
<span class="c1"># you must use a few batches of real data.</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">static_target</span><span class="p">)</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># capture</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>
<span class="c1"># Sets grads to None before capture, so backward() will create</span>
<span class="c1"># .grad attributes with allocations from the graph&#39;s private pool</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="n">static_y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span>
    <span class="n">static_loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">static_y_pred</span><span class="p">,</span> <span class="n">static_target</span><span class="p">)</span>
    <span class="n">static_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

<span class="n">real_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">real_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">static_target</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">real_inputs</span><span class="p">,</span> <span class="n">real_targets</span><span class="p">):</span>
    <span class="c1"># Fills the graph&#39;s input memory with new data to compute on</span>
    <span class="n">static_input</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">static_target</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="c1"># replay() includes forward, backward, and step.</span>
    <span class="c1"># You don&#39;t even need to call optimizer.zero_grad() between iterations</span>
    <span class="c1"># because the captured backward refills static .grad tensors in place.</span>
    <span class="n">g</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
    <span class="c1"># Params have been updated. static_y_pred, static_loss, and .grad</span>
    <span class="c1"># attributes hold values from computing on this iteration&#39;s data.</span>
</pre></div>
</div>
</section>
<section id="partial-network-capture">
<span id="id4"></span><h3>Partial-network capture<a class="headerlink" href="#partial-network-capture" title="Link to this heading">#</a></h3>
<p>If some of your network is unsafe to capture (e.g., due to dynamic control flow,
dynamic shapes, CPU syncs, or essential CPU-side logic), you can run the unsafe
part(s) eagerly and use <a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables()</span></code></a> to graph only
the capture-safe part(s).</p>
<p>By default, callables returned by <a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a>
are autograd-aware, and can be used in the training loop as direct replacements
for the functions or <a class="reference internal" href="../generated/torch.nn.Module.html#torch.nn.Module" title="torch.nn.Module"><code class="xref py py-class docutils literal notranslate"><span class="pre">nn.Module</span></code></a>s you passed.</p>
<p><a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> internally creates
<a class="reference internal" href="../generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph" title="torch.cuda.CUDAGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">CUDAGraph</span></code></a> objects, runs warmup iterations, and maintains
static inputs and outputs as needed.  Therefore (unlike with
<a class="reference internal" href="../generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a>) you dont need to handle those manually.</p>
<p>In the following example, data-dependent dynamic control flow means the
network isnt capturable end-to-end, but
<a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a>
lets us capture and run graph-safe sections as graphs regardless:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">D_in</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">D_out</span> <span class="o">=</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">1024</span>

<span class="n">module1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">D_in</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="n">module2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">D_out</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="n">module3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">D_out</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">module1</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span>
                                  <span class="n">module2</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span>
                                  <span class="n">module3</span><span class="o">.</span><span class="n">parameters</span><span class="p">()),</span>
                            <span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Sample inputs used for capture</span>
<span class="c1"># requires_grad state of sample inputs must match</span>
<span class="c1"># requires_grad state of real inputs each callable will see.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D_in</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">module1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">make_graphed_callables</span><span class="p">(</span><span class="n">module1</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,))</span>
<span class="n">module2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">make_graphed_callables</span><span class="p">(</span><span class="n">module2</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,))</span>
<span class="n">module3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">make_graphed_callables</span><span class="p">(</span><span class="n">module3</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,))</span>

<span class="n">real_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">real_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D_out</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">real_inputs</span><span class="p">,</span> <span class="n">real_targets</span><span class="p">):</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">module1</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># forward ops run as a graph</span>

    <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">module2</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>  <span class="c1"># forward ops run as a graph</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">module3</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>  <span class="c1"># forward ops run as a graph</span>

    <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="c1"># module2&#39;s or module3&#39;s (whichever was chosen) backward ops,</span>
    <span class="c1"># as well as module1&#39;s backward ops, run as graphs</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="usage-with-torch-cuda-amp">
<span id="graphs-with-amp"></span><h3>Usage with torch.cuda.amp<a class="headerlink" href="#usage-with-torch-cuda-amp" title="Link to this heading">#</a></h3>
<p>For typical optimizers, <code class="xref py py-meth docutils literal notranslate"><span class="pre">GradScaler.step</span></code> syncs
the CPU with the GPU, which is prohibited during capture. To avoid errors, either use
<a class="reference internal" href="#partial-network-capture"><span class="std std-ref">partial-network capture</span></a>, or (if forward, loss,
and backward are capture-safe) capture forward, loss, and backward but not the
optimizer step:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># warmup</span>
<span class="c1"># In a real setting, use a few batches of real data.</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">():</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">static_target</span><span class="p">)</span>
        <span class="n">scaler</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">scaler</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">optimizer</span><span class="p">)</span>
        <span class="n">scaler</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># capture</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">():</span>
        <span class="n">static_y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span>
        <span class="n">static_loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">static_y_pred</span><span class="p">,</span> <span class="n">static_target</span><span class="p">)</span>
    <span class="n">scaler</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">static_loss</span><span class="p">)</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="c1"># don&#39;t capture scaler.step(optimizer) or scaler.update()</span>

<span class="n">real_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">real_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">static_target</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">real_inputs</span><span class="p">,</span> <span class="n">real_targets</span><span class="p">):</span>
    <span class="n">static_input</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">static_target</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
    <span class="c1"># Runs scaler.step and scaler.update eagerly</span>
    <span class="n">scaler</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">optimizer</span><span class="p">)</span>
    <span class="n">scaler</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="usage-with-multiple-streams">
<span id="multistream-capture"></span><h3>Usage with multiple streams<a class="headerlink" href="#usage-with-multiple-streams" title="Link to this heading">#</a></h3>
<p>Capture mode automatically propagates to any streams that sync with a capturing stream.
Within capture, you may expose parallelism by issuing calls to different streams,
but the overall stream dependency DAG must branch out from the
initial capturing stream after capture begins and rejoin the initial stream
before capture ends:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="c1"># at context manager entrance, torch.cuda.current_stream()</span>
    <span class="c1"># is the initial capturing stream</span>

    <span class="c1"># INCORRECT (does not branch out from or rejoin initial stream)</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">cuda_work</span><span class="p">()</span>

    <span class="c1"># CORRECT:</span>
    <span class="c1"># branches out from initial stream</span>
    <span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">cuda_work</span><span class="p">()</span>
    <span class="c1"># rejoins initial stream before capture ends</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To avoid confusion for power users looking at replays in nsight systems or nvprof:
Unlike eager execution, the graph interprets a nontrivial stream DAG in capture
as a hint, not a command. During replay, the graph may reorganize independent ops
onto different streams or enqueue them in a different order (while respecting your
original DAGs overall dependencies).</p>
</div>
</section>
<section id="usage-with-distributeddataparallel">
<h3>Usage with DistributedDataParallel<a class="headerlink" href="#usage-with-distributeddataparallel" title="Link to this heading">#</a></h3>
<section id="nccl-2-9-6">
<h4>NCCL &lt; 2.9.6<a class="headerlink" href="#nccl-2-9-6" title="Link to this heading">#</a></h4>
<p>NCCL versions earlier than 2.9.6 dont allow collectives to be captured.
You must use <a class="reference internal" href="#partial-network-capture"><span class="std std-ref">partial-network capture</span></a>,
which defers allreduces to happen outside graphed sections of backward.</p>
<p>Call <a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> on graphable network sections
<em>before</em> wrapping the network with DDP.</p>
</section>
<section id="id5">
<h4>NCCL &gt;= 2.9.6<a class="headerlink" href="#id5" title="Link to this heading">#</a></h4>
<p>NCCL versions 2.9.6 or later allow collectives in the graph.
Approaches that capture an <a class="reference internal" href="#whole-network-capture"><span class="std std-ref">entire backward pass</span></a>
are a viable option, but need three setup steps.</p>
<ol class="arabic">
<li><p>Disable DDPs internal async error handling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;NCCL_ASYNC_ERROR_HANDLING&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">init_process_group</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Before full-backward capture, DDP must be constructed in a side-stream context:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">DistributedDataParallel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Your warmup must run at least 11 DDP-enabled eager iterations before capture.</p></li>
</ol>
</section>
</section>
<section id="graph-memory-management">
<span id="id6"></span><h3>Graph memory management<a class="headerlink" href="#graph-memory-management" title="Link to this heading">#</a></h3>
<p>A captured graph acts on the same virtual addresses every time it replays.
If PyTorch frees the memory, a later replay can hit an illegal memory access.
If PyTorch reassigns the memory to new tensors, the replay can corrupt the values
seen by those tensors.  Therefore, the virtual addresses used by the graph must be
reserved for the graph across replays. The PyTorch caching allocator achieves this
by detecting when capture is underway and satisfying the captures allocations
from a graph-private memory pool. The private pool stays alive until its
<a class="reference internal" href="../generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph" title="torch.cuda.CUDAGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">CUDAGraph</span></code></a> object and all tensors created during capture
go out of scope.</p>
<p>Private pools are maintained automatically. By default, the allocator creates a
separate private pool for each capture. If you capture multiple graphs,
this conservative approach ensures graph replays never corrupt each others values,
but sometimes needlessly wastes memory.</p>
<section id="sharing-memory-across-captures">
<h4>Sharing memory across captures<a class="headerlink" href="#sharing-memory-across-captures" title="Link to this heading">#</a></h4>
<p>To economize the memory stashed in private pools, <a class="reference internal" href="../generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a>
and <a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables()</span></code></a> optionally allow different
captures to share the same private pool.
Its safe for a set of graphs to share a private pool if you know theyll always
be replayed in the same order they were captured,
and never be replayed concurrently.</p>
<p><a class="reference internal" href="../generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a>s <code class="docutils literal notranslate"><span class="pre">pool</span></code> argument is a hint to use a particular private pool,
and can be used to share memory across graphs as shown:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>

<span class="c1"># (create static inputs for g1 and g2, run warmups of their workloads...)</span>

<span class="c1"># Captures g1</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g1</span><span class="p">):</span>
    <span class="n">static_out_1</span> <span class="o">=</span> <span class="n">g1_workload</span><span class="p">(</span><span class="n">static_in_1</span><span class="p">)</span>

<span class="c1"># Captures g2, hinting that g2 may share a memory pool with g1</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="n">g1</span><span class="o">.</span><span class="n">pool</span><span class="p">()):</span>
    <span class="n">static_out_2</span> <span class="o">=</span> <span class="n">g2_workload</span><span class="p">(</span><span class="n">static_in_2</span><span class="p">)</span>

<span class="n">static_in_1</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">real_data_1</span><span class="p">)</span>
<span class="n">static_in_2</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">real_data_2</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
<span class="n">g2</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
</pre></div>
</div>
<p>Its also safe to share a memory pool across separate graphs that do not depend
on each others outputs, provided they never run concurrently.
Be aware that replaying one graph can clobber another graphs outputs when
they share a pool, unless <a class="reference internal" href="../generated/torch.Tensor.clone.html#torch.Tensor.clone" title="torch.Tensor.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code></a> is called on the outputs
beforehand.
This pattern is frequently used in inference servers that accept variable batch
sizes at runtime.
vLLM is a notable example; see <a class="reference external" href="https://github.com/vllm-project/vllm/blob/938a81692ea318e59ead4750e7e7425bfd6a4896/vllm/platforms/interface.py#L508-L515">here</a>
and <a class="reference external" href="https://github.com/vllm-project/vllm/blob/938a81692ea318e59ead4750e7e7425bfd6a4896/vllm/compilation/cuda_graph.py#L86-L89">here</a>.</p>
<p>With <a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables()</span></code></a>, if you want to graph several
callables and you know theyll always run in the same order (and never concurrently)
pass them as a tuple in the same order theyll run in the live workload, and
<a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> will capture their graphs using a shared
private pool.</p>
<p>If, in the live workload, your callables will run in an order that occasionally changes,
or if theyll run concurrently, passing them as a tuple to a single invocation of
<a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> is not allowed. Instead, you must call
<a class="reference internal" href="../generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> separately for each one.</p>
</section>
</section>
</section>
</section>


                </article>
              
  </article>
  
              
              
                <footer class="bd-footer-article">
                  <div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item">
<div class="feedback">
  
<div class="rating">
    Rate this Page
    <div class="stars">
        
        <span class="star" data-behavior="tutorial-rating" data-count="1" data-value="1"></span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="2" data-value="2"></span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="3" data-value="3"></span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="4" data-value="4"></span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="5" data-value="5"></span>
        
    </div>
</div>

  <div class="feedback-send">
    <button class="feedback-btn"
            onclick="openGitHubIssue()"
            data-bs-title="Create a GitHub Issue"
            data-bs-placement="bottom"
            data-bs-toggle="tooltip"
            data-gtm="feedback-btn-click">Send Feedback
    </button>
  </div>
</div>

<div class="prev-next-area">
    <a class="left-prev"
       href="cpu_threading_torchscript_inference.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">CPU threading and TorchScript inference</p>
      </div>
    </a>
    <a class="right-next"
       href="custom_operators.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">PyTorch Custom Operators Landing Page</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>

<div class="footer-info">
  <p class="copyright">
    
  </p>

  <p class="theme-version">
    Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
  </p>
</div>
</div>
  
</div>
                </footer>
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="cpu_threading_torchscript_inference.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">CPU threading and TorchScript inference</p>
      </div>
    </a>
    <a class="right-next"
       href="custom_operators.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">PyTorch Custom Operators Landing Page</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc">
<div class="sidebar-secondary-items sidebar-secondary__inner">
    
       <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tensorfloat-32-tf32-on-ampere-and-later-devices">TensorFloat-32 (TF32) on Ampere (and later) devices</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#reduced-precision-reduction-in-fp16-gemms">Reduced Precision Reduction in FP16 GEMMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#reduced-precision-reduction-in-bf16-gemms">Reduced Precision Reduction in BF16 GEMMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#full-fp16-accumulation-in-fp16-gemms">Full FP16 Accumulation in FP16 GEMMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#asynchronous-execution">Asynchronous execution</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cuda-streams">CUDA streams</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#stream-semantics-of-backward-passes">Stream semantics of backward passes</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#bc-note-using-grads-on-the-default-stream">BC note: Using grads on the default stream</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-management">Memory management</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optimizing-memory-usage-with-pytorch-alloc-conf">Optimizing memory usage  with <code class="docutils literal notranslate"><span class="pre">PYTORCH_ALLOC_CONF</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-custom-memory-allocators-for-cuda">Using custom memory allocators for CUDA</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mixing-different-cuda-system-allocators-in-the-same-program">Mixing different CUDA system allocators in the same program</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tuning-nvlink-performance-with-custom-memory-allocator-on-h100-h200-gpus">Tuning NVLink Performance with Custom Memory Allocator on H100/H200 GPUs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cublas-workspaces">cuBLAS workspaces</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cufft-plan-cache">cuFFT plan cache</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#just-in-time-compilation">Just-in-Time Compilation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#best-practices">Best practices</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#device-agnostic-code">Device-agnostic code</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-pinned-memory-buffers">Use pinned memory buffers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-nn-parallel-distributeddataparallel-instead-of-multiprocessing-or-nn-dataparallel">Use nn.parallel.DistributedDataParallel instead of multiprocessing or nn.DataParallel</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cuda-graphs">CUDA Graphs</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-cuda-graphs">Why CUDA Graphs?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pytorch-api">PyTorch API</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#constraints">Constraints</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#non-constraints">Non-constraints</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#whole-network-capture">Whole-network capture</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#partial-network-capture">Partial-network capture</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#usage-with-torch-cuda-amp">Usage with torch.cuda.amp</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#usage-with-multiple-streams">Usage with multiple streams</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#usage-with-distributeddataparallel">Usage with DistributedDataParallel</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#nccl-2-9-6">NCCL &lt; 2.9.6</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">NCCL &gt;= 2.9.6</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-memory-management">Graph memory management</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#sharing-memory-across-captures">Sharing memory across captures</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>
    
       <div class="sidebar-secondary-item">

  
  <div class="tocsection editthispage">
    <a href="https://github.com/pytorch/pytorch/edit/main/docs/source/notes/cuda.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>
    
       <div class="sidebar-secondary-item">
    <div class="tocsection sourcelink">
      <a href="../_sources/notes/cuda.rst.txt">
        <i class="fa-solid fa-file-lines"></i> Show Source
      </a>
    </div>
</div>
    




<div class="sidebar-secondary-item">
  <div class="sidebar-heading">PyTorch Libraries</div>
  <ul style="list-style-type: none; padding: 0; padding-bottom: 80px;">
  
   <li><a class="nav-link nav-external" href="https://docs.pytorch.org/ao" style="color: var(--pst-color-text-muted)">torchao</a></li>
  
   <li><a class="nav-link nav-external" href="https://docs.pytorch.org/torchrec" style="color: var(--pst-color-text-muted)">torchrec</a></li>
  
   <li><a class="nav-link nav-external" href="https://docs.pytorch.org/torchft" style="color: var(--pst-color-text-muted)">torchft</a></li>
  
   <li><a class="nav-link nav-external" href="https://docs.pytorch.org/torchcodec" style="color: var(--pst-color-text-muted)">TorchCodec</a></li>
  
   <li><a class="nav-link nav-external" href="https://docs.pytorch.org/vision" style="color: var(--pst-color-text-muted)">torchvision</a></li>
  
   <li><a class="nav-link nav-external" href="https://docs.pytorch.org/executorch" style="color: var(--pst-color-text-muted)">ExecuTorch</a></li>
  
   <li><a class="nav-link nav-external" href="https://docs.pytorch.org/xla" style="color: var(--pst-color-text-muted)">PyTorch on XLA Devices</a></li>
  
  </ul>
</div>

</div>
</div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  

<div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
  <div class="container">
    <div class="row">
      <div class="col-md-4">
        <h2>Docs</h2>
        <p>Access comprehensive developer documentation for PyTorch</p>
        <a class="with-right-arrow" href="https://docs.pytorch.org/docs/stable/index.html">View Docs</a>
      </div>

      <div class="col-md-4">
        <h2>Tutorials</h2>
        <p>Get in-depth tutorials for beginners and advanced developers</p>
        <a class="with-right-arrow" href="https://docs.pytorch.org/tutorials">View Tutorials</a>
      </div>

      <div class="col-md-4">
        <h2>Resources</h2>
        <p>Find development resources and get your questions answered</p>
        <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
      </div>
    </div>
  </div>
</div>




<footer class="site-footer">

  <div class="container footer-container">

    <div class="newsletter" id="newsletter">

      <p class="newsletter__title is-style-max-width-800"><strong>Stay in touch</strong> for updates, event info, and
        the latest news</p>


      <script charset="utf-8" type="text/javascript" src="//js.hsforms.net/forms/embed/v2.js"></script>
      <script>
        hbspt.forms.create({
          region: "na1",
          portalId: "8112310",
          formId: "2fb2231c-000b-4ec5-88a0-1ab242549c9e"
        });
      </script>


      <p class="newsletter__privacy">By submitting this form, I consent to receive marketing emails from the LF and its
        projects regarding their events, training, research, developments, and related announcements. I understand that
        I can unsubscribe at any time using the links in the footers of the emails I receive. <a
          href="https://www.linuxfoundation.org/privacy/">Privacy Policy</a>.</p>

    </div>

    <div class="lf-grid">
      <ul class="social-links">
        <li><a href="https://www.facebook.com/pytorch" target="_blank" title="PyTorch on Facebook">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="-0.51 -0.26 26.45 26.45" aria-label="Facebook">
              <path fill="currentColor"
                d="M25.497 13.075c0-2.45-.698-4.848-2.011-6.911a12.765 12.765 0 0 0-5.398-4.73A12.671 12.671 0 0 0 11.008.38a12.705 12.705 0 0 0-6.529 2.95A12.827 12.827 0 0 0 .563 9.358a12.896 12.896 0 0 0-.07 7.201 12.831 12.831 0 0 0 3.801 6.103 12.709 12.709 0 0 0 6.471 3.078v-8.957H7.53v-3.708h3.235v-2.824c0-3.213 1.903-4.988 4.813-4.988.956.014 1.909.097 2.852.25V8.67h-1.607a1.83 1.83 0 0 0-1.518.497 1.854 1.854 0 0 0-.561 1.505v2.404h3.535l-.563 3.708h-2.97v8.957a12.725 12.725 0 0 0 7.697-4.337 12.87 12.87 0 0 0 3.054-8.328z" />
            </svg>
          </a></li>
        <li><a href="https://twitter.com/pytorch" target="_blank" title="PyTorch on X">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 300 300" aria-label="X">
              <path fill="currentColor"
                d="M178.57 127.15 290.27 0h-26.46l-97.03 110.38L89.34 0H0l117.13 166.93L0 300.25h26.46l102.4-116.59 81.8 116.59h89.34M36.01 19.54H76.66l187.13 262.13h-40.66" />
            </svg>
          </a></li>
        <li><a href="https://www.youtube.com/pytorch" target="_blank" title="PyTorch on YouTube">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0.21 0.27 34.45 25.07" aria-label="YouTube">
              <path fill="currentColor"
                d="M33.729 6.084s-.327-2.33-1.317-3.356a4.691 4.691 0 0 0-3.32-1.432c-4.634-.34-11.589-.34-11.589-.34h-.014s-6.954 0-11.59.342a4.692 4.692 0 0 0-3.32 1.432c-.993 1.025-1.315 3.354-1.315 3.354a52.189 52.189 0 0 0-.331 5.473v2.566c.014 1.829.125 3.656.331 5.472 0 0 .322 2.33 1.316 3.36 1.26 1.345 2.916 1.3 3.653 1.445 2.65.26 11.263.34 11.263.34s6.96-.01 11.597-.353a4.691 4.691 0 0 0 3.32-1.432c.993-1.026 1.316-3.356 1.316-3.356.206-1.817.316-3.644.33-5.473v-2.57a52.26 52.26 0 0 0-.33-5.472zM14.076 17.232V7.729l8.951 4.768-8.95 4.735z" />
            </svg>
          </a></li>
        <li><a href="https://www.linkedin.com/company/pytorch" target="_blank" title="PyTorch on LinkedIn">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="-10.23 -10.23 531.96 531.96" aria-label="LinkedIn">
              <rect width="512" height="512" rx="0" fill="currentColor" />
              <circle fill="#000" cx="142" cy="138" r="37" />
              <path stroke="#000" stroke-width="66" d="M244 194v198M142 194v198" />
              <path fill="#000"
                d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32" />
            </svg>
          </a></li>
        <li><a href="https://pytorch.slack.com" target="_blank" title="PyTorch Slack">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0.16 -0.03 21.19 21.19" aria-label="Slack">
              <path fill="currentColor"
                d="M4.896 13.27a2.147 2.147 0 0 1-2.141 2.142A2.147 2.147 0 0 1 .613 13.27c0-1.178.963-2.141 2.142-2.141h2.141v2.141zm1.08 0c0-1.178.962-2.141 2.141-2.141s2.142.963 2.142 2.141v5.363a2.147 2.147 0 0 1-2.142 2.141 2.147 2.147 0 0 1-2.141-2.142V13.27zm2.141-8.6a2.147 2.147 0 0 1-2.141-2.14c0-1.18.962-2.142 2.141-2.142s2.142.963 2.142 2.141v2.142H8.117zm0 1.08c1.179 0 2.141.962 2.141 2.141a2.147 2.147 0 0 1-2.141 2.142H2.755A2.147 2.147 0 0 1 .613 7.89c0-1.179.963-2.141 2.142-2.141h5.362zm8.599 2.141c0-1.179.963-2.141 2.141-2.141 1.179 0 2.143.962 2.143 2.14a2.147 2.147 0 0 1-2.142 2.142h-2.141V7.89zm-1.08 0a2.147 2.147 0 0 1-2.141 2.142 2.147 2.147 0 0 1-2.141-2.142V2.53c0-1.178.962-2.141 2.141-2.141s2.142.963 2.142 2.141v5.362zm-2.141 8.6c1.179 0 2.142.962 2.142 2.14a2.147 2.147 0 0 1-2.142 2.142 2.147 2.147 0 0 1-2.141-2.141V16.49h2.141zm0-1.08a2.147 2.147 0 0 1-2.141-2.141c0-1.179.962-2.142 2.141-2.142h5.362c1.179 0 2.142.963 2.142 2.142a2.147 2.147 0 0 1-2.142 2.142h-5.362z">
              </path>
            </svg>
          </a></li>
        <li><a href="https://pytorch.org/wechat" title="PyTorch on WeChat">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0.14 -0.17 38.02 33.02" aria-label="WeChat">
              <path fill="currentColor"
                d="M26.289 10.976a12.972 12.972 0 0 0-8.742 3.53 10.386 10.386 0 0 0-3.224 8.795c-1.326-.164-2.535-.345-3.75-.448a2.332 2.332 0 0 0-1.273.216c-1.18.666-2.311 1.418-3.652 2.255.246-1.112.405-2.087.687-3.024a1.15 1.15 0 0 0-.523-1.52C1.737 17.902.02 13.601 1.307 9.165c1.189-4.1 4.11-6.587 8.077-7.884A13.54 13.54 0 0 1 24.18 5.617a10.135 10.135 0 0 1 2.109 5.359zM10.668 9.594a1.564 1.564 0 0 0-2.095-1.472 1.52 1.52 0 0 0-.895 1.964 1.502 1.502 0 0 0 1.391.966 1.545 1.545 0 0 0 1.598-1.46v.002zm8.15-1.566a1.567 1.567 0 0 0-1.528 1.543 1.528 1.528 0 0 0 1.571 1.492 1.52 1.52 0 0 0 1.375-2.117 1.518 1.518 0 0 0-1.415-.919l-.003.001z">
              </path>
              <path fill="currentColor"
                d="M33.914 32.137c-1.075-.478-2.062-1.196-3.11-1.306-1.049-.11-2.145.494-3.24.605a10.821 10.821 0 0 1-8.781-2.864c-4.682-4.33-4.013-10.97 1.403-14.518 4.811-3.154 11.874-2.102 15.268 2.273a8.671 8.671 0 0 1-1.002 12.095c-1.046.929-1.422 1.693-.751 2.917.102.257.174.525.213.798zM21.68 20.292a1.264 1.264 0 1 0 .01-2.528 1.264 1.264 0 0 0-.01 2.528zm7.887-2.526a1.266 1.266 0 0 0-1.256 1.21 1.247 1.247 0 1 0 1.256-1.21z">
              </path>
            </svg>
          </a></li>
      </ul>
    </div>
    
    <div class="privacy-policy">
      <div class="copyright">
      
        <p>
          &copy; PyTorch. Copyright  The Linux Foundation. All rights reserved. The Linux Foundation has registered
          trademarks and uses trademarks. For more information, including terms of use, privacy policy, and trademark
          usage, please see our <a href="https://www.linuxfoundation.org/legal/policies">Policies</a> page. <a
            href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a>. <a
            href="http://www.linuxfoundation.org/privacy">Privacy Policy</a>.
        </p>
        
      </div>
    </div>


  </div>
</footer>

<div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebooks Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../_static/img/pytorch-x.svg">
  </div>
</div>
  
  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright PyTorch Contributors.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  <script type="application/ld+json">
    {
       "@context": "https://schema.org",
       "@type": "Article",
       "name": "CUDA semantics",
       "headline": "CUDA semantics",
       "description": "PyTorch Documentation. Explore PyTorch, an open-source machine learning library that accelerates the path from research prototyping to production deployment. Discover tutorials, API references, and guides to help you build and deploy deep learning models efficiently.",
       "url": "/notes/cuda.html",
       "articleBody": "CUDA semantics# Created On: Jan 16, 2017 | Last Updated On: Dec 09, 2025 torch.cuda is used to set up and run CUDA operations. It keeps track of the currently selected GPU, and all CUDA tensors you allocate will by default be created on that device. The selected device can be changed with a torch.cuda.device context manager. However, once a tensor is allocated, you can do operations on it irrespective of the selected device, and the results will be always placed on the same device as the tensor. Cross-GPU operations are not allowed by default, with the exception of copy_() and other methods with copy-like functionality such as to() and cuda(). Unless you enable peer-to-peer memory access, any attempts to launch ops on tensors spread across different devices will raise an error. Below you can find a small example showcasing this: cuda = torch.device(\u0027cuda\u0027) # Default CUDA device cuda0 = torch.device(\u0027cuda:0\u0027) cuda2 = torch.device(\u0027cuda:2\u0027) # GPU 2 (these are 0-indexed) x = torch.tensor([1., 2.], device=cuda0) # x.device is device(type=\u0027cuda\u0027, index=0) y = torch.tensor([1., 2.]).cuda() # y.device is device(type=\u0027cuda\u0027, index=0) with torch.cuda.device(1): # allocates a tensor on GPU 1 a = torch.tensor([1., 2.], device=cuda) # transfers a tensor from CPU to GPU 1 b = torch.tensor([1., 2.]).cuda() # a.device and b.device are device(type=\u0027cuda\u0027, index=1) # You can also use ``Tensor.to`` to transfer a tensor: b2 = torch.tensor([1., 2.]).to(device=cuda) # b.device and b2.device are device(type=\u0027cuda\u0027, index=1) c = a + b # c.device is device(type=\u0027cuda\u0027, index=1) z = x + y # z.device is device(type=\u0027cuda\u0027, index=0) # even within a context, you can specify the device # (or give a GPU index to the .cuda call) d = torch.randn(2, device=cuda2) e = torch.randn(2).to(cuda2) f = torch.randn(2).cuda(cuda2) # d.device, e.device, and f.device are all device(type=\u0027cuda\u0027, index=2) TensorFloat-32 (TF32) on Ampere (and later) devices# After Pytorch 2.9, we provide a new sets of APIs to control the TF32 behavior in a more fine-grained way, and suggest to use the new APIs for better control. We can set float32 precision per backend and per operators. We can also override the global setting for a specific operator. torch.backends.fp32_precision = \"ieee\" torch.backends.cuda.matmul.fp32_precision = \"ieee\" torch.backends.cudnn.fp32_precision = \"ieee\" torch.backends.cudnn.conv.fp32_precision = \"tf32\" torch.backends.cudnn.rnn.fp32_precision = \"tf32\" The fp32_precision can be set to ieee or tf32 for cuda/cudnn. ieee fp32_precision indicate that we will use FP32 as internal computation precision. tf32 fp32_precision indicate that we will allow to use TF32 as internal computation precision. We can override a generic setting for a specific operator if the fp32_precision is set to ieee. torch.backends.cudnn.fp32_precision = \"tf32\" torch.backends.cudnn.conv.fp32_precision = \"ieee\" torch.backends.cudnn.rnn.fp32_precision = \"ieee\" We can also override a generic setting for a specific backend if the fp32_precision is set to ieee. torch.backends.fp32_precision = \"tf32\" torch.backends.cudnn.fp32_precision = \"ieee\" torch.backends.cudnn.conv.fp32_precision = \"ieee\" torch.backends.cudnn.rnn.fp32_precision = \"ieee\" For above 2 cases, both torch.backends.cudnn.conv.fp32_precision and torch.backends.cudnn.rnn.fp32_precision is overridden to ieee. We suggest to use the new settings for better control. And we do not support to use mix of old and new settings. Warning Old settings with allow_tf32 as follows is going to be deprecated. We suggest to use the above new settings for better control. And we do not support to use mix of old and new settings. Starting in PyTorch 1.7, there is a new flag called allow_tf32. This flag defaults to True in PyTorch 1.7 to PyTorch 1.11, and False in PyTorch 1.12 and later. This flag controls whether PyTorch is allowed to use the TensorFloat32 (TF32) tensor cores, available on NVIDIA GPUs since Ampere, internally to compute matmul (matrix multiplies and batched matrix multiplies) and convolutions. TF32 tensor cores are designed to achieve better performance on matmul and convolutions on torch.float32 tensors by rounding input data to have 10 bits of mantissa, and accumulating results with FP32 precision, maintaining FP32 dynamic range. matmuls and convolutions are controlled separately, and their corresponding flags can be accessed at: # The flag below controls whether to allow TF32 on matmul. This flag defaults to False # in PyTorch 1.12 and later. torch.backends.cuda.matmul.allow_tf32 = True # The flag below controls whether to allow TF32 on cuDNN. This flag defaults to True. torch.backends.cudnn.allow_tf32 = True The precision of matmuls can also be set more broadly (limited not just to CUDA) via set_float32_matmul_precision(). Note that besides matmuls and convolutions themselves, functions and nn modules that internally uses matmuls or convolutions are also affected. These include nn.Linear, nn.Conv*, cdist, tensordot, affine grid and grid sample, adaptive log softmax, GRU and LSTM. To get an idea of the precision and speed, see the example code and benchmark data (on A100) below: a_full = torch.randn(10240, 10240, dtype=torch.double, device=\u0027cuda\u0027) b_full = torch.randn(10240, 10240, dtype=torch.double, device=\u0027cuda\u0027) ab_full = a_full @ b_full mean = ab_full.abs().mean() # 80.7277 a = a_full.float() b = b_full.float() # Do matmul at TF32 mode. torch.backends.cuda.matmul.allow_tf32 = True ab_tf32 = a @ b # takes 0.016s on GA100 error = (ab_tf32 - ab_full).abs().max() # 0.1747 relative_error = error / mean # 0.0022 # Do matmul with TF32 disabled. torch.backends.cuda.matmul.allow_tf32 = False ab_fp32 = a @ b # takes 0.11s on GA100 error = (ab_fp32 - ab_full).abs().max() # 0.0031 relative_error = error / mean # 0.000039 From the above example, we can see that with TF32 enabled, the speed is ~7x faster on A100, and that relative error compared to double precision is approximately 2 orders of magnitude larger. Note that the exact ratio of TF32 to single precision speed depends on the hardware generation, as properties such as the ratio of memory bandwidth to compute as well as the ratio of TF32 to FP32 matmul throughput may vary from generation to generation or model to model. If full FP32 precision is needed, users can disable TF32 by: torch.backends.cuda.matmul.allow_tf32 = False torch.backends.cudnn.allow_tf32 = False To toggle the TF32 flags off in C++, you can do at::globalContext().setAllowTF32CuBLAS(false); at::globalContext().setAllowTF32CuDNN(false); For more information about TF32, see: TensorFloat-32 CUDA 11 Ampere architecture Reduced Precision Reduction in FP16 GEMMs# (Distinct from full FP16 accumulation that is intended for hardware that has higher throughput with FP16 accumulation than FP32 accumulation, see Full FP16 accumulation) fp16 GEMMs are potentially done with some intermediate reduced precision reductions (e.g., in fp16 rather than fp32). These selective reductions in precision can allow for higher performance on certain workloads (particularly those with a large k dimension) and GPU architectures at the cost of numerical precision and potential for overflow. Some example benchmark data on V100: [--------------------------- bench_gemm_transformer --------------------------] [ m , k , n ] | allow_fp16_reduc=True | allow_fp16_reduc=False 1 threads: -------------------------------------------------------------------- [4096, 4048, 4096] | 1634.6 | 1639.8 [4096, 4056, 4096] | 1670.8 | 1661.9 [4096, 4080, 4096] | 1664.2 | 1658.3 [4096, 4096, 4096] | 1639.4 | 1651.0 [4096, 4104, 4096] | 1677.4 | 1674.9 [4096, 4128, 4096] | 1655.7 | 1646.0 [4096, 4144, 4096] | 1796.8 | 2519.6 [4096, 5096, 4096] | 2094.6 | 3190.0 [4096, 5104, 4096] | 2144.0 | 2663.5 [4096, 5112, 4096] | 2149.1 | 2766.9 [4096, 5120, 4096] | 2142.8 | 2631.0 [4096, 9728, 4096] | 3875.1 | 5779.8 [4096, 16384, 4096] | 6182.9 | 9656.5 (times in microseconds). If full precision reductions are needed, users can disable reduced precision reductions in fp16 GEMMs with: torch.backends.cuda.matmul.allow_fp16_reduced_precision_reduction = False To toggle the reduced precision reduction flags in C++, one can do at::globalContext().setAllowFP16ReductionCuBLAS(false); Reduced Precision Reduction in BF16 GEMMs# A similar flag (as above) exists for BFloat16 GEMMs. Note that this switch is set to True by default for BF16, if you observe numerical instability in your workload, you may wish to set it to False. If reduced precision reductions are not desired, users can disable reduced precision reductions in bf16 GEMMs with: torch.backends.cuda.matmul.allow_bf16_reduced_precision_reduction = False To toggle the reduced precision reduction flags in C++, one can do at::globalContext().setAllowBF16ReductionCuBLAS(true); Full FP16 Accumulation in FP16 GEMMs# Certain GPUs have increased performance when doing _all_ FP16 GEMM accumulation in FP16, at the cost of numerical precision and greater likelihood of overflow. Note that this setting only has an effect on GPUs of compute capability 7.0 (Volta) or newer. This behavior can be enabled via: torch.backends.cuda.matmul.allow_fp16_accumulation = True To toggle the reduced precision reduction flags in C++, one can do at::globalContext().setAllowFP16AccumulationCuBLAS(true); Asynchronous execution# By default, GPU operations are asynchronous. When you call a function that uses the GPU, the operations are enqueued to the particular device, but not necessarily executed until later. This allows us to execute more computations in parallel, including operations on CPU or other GPUs. In general, the effect of asynchronous computation is invisible to the caller, because (1) each device executes operations in the order they are queued, and (2) PyTorch automatically performs necessary synchronization when copying data between CPU and GPU or between two GPUs. Hence, computation will proceed as if every operation was executed synchronously. You can force synchronous computation by setting environment variable CUDA_LAUNCH_BLOCKING=1. This can be handy when an error occurs on the GPU. (With asynchronous execution, such an error isn\u2019t reported until after the operation is actually executed, so the stack trace does not show where it was requested.) A consequence of the asynchronous computation is that time measurements without synchronizations are not accurate. To get precise measurements, one should either call torch.cuda.synchronize() before measuring, or use torch.cuda.Event to record times as following: start_event = torch.cuda.Event(enable_timing=True) end_event = torch.cuda.Event(enable_timing=True) start_event.record() # Run some things here end_event.record() torch.cuda.synchronize() # Wait for the events to be recorded! elapsed_time_ms = start_event.elapsed_time(end_event) As an exception, several functions such as to() and copy_() admit an explicit non_blocking argument, which lets the caller bypass synchronization when it is unnecessary. Another exception is CUDA streams, explained below. CUDA streams# A CUDA stream is a linear sequence of execution that belongs to a specific device. You normally do not need to create one explicitly: by default, each device uses its own \u201cdefault\u201d stream. Operations inside each stream are serialized in the order they are created, but operations from different streams can execute concurrently in any relative order, unless explicit synchronization functions (such as synchronize() or wait_stream()) are used. For example, the following code is incorrect: cuda = torch.device(\u0027cuda\u0027) s = torch.cuda.Stream() # Create a new stream. A = torch.empty((100, 100), device=cuda).normal_(0.0, 1.0) with torch.cuda.stream(s): # sum() may start execution before normal_() finishes! B = torch.sum(A) When the \u201ccurrent stream\u201d is the default stream, PyTorch automatically performs necessary synchronization when data is moved around, as explained above. However, when using non-default streams, it is the user\u2019s responsibility to ensure proper synchronization. The fixed version of this example is: cuda = torch.device(\u0027cuda\u0027) s = torch.cuda.Stream() # Create a new stream. A = torch.empty((100, 100), device=cuda).normal_(0.0, 1.0) s.wait_stream(torch.cuda.default_stream(cuda)) # NEW! with torch.cuda.stream(s): B = torch.sum(A) A.record_stream(s) # NEW! There are two new additions. The torch.cuda.Stream.wait_stream() call ensures that the normal_() execution has finished before we start running sum(A) on a side stream. The torch.Tensor.record_stream() (see for more details) ensures that we do not deallocate A before sum(A) has completed. You can also manually wait on the stream at some later point in time with torch.cuda.default_stream(cuda).wait_stream(s) (note that it is pointless to wait immediately, since that will prevent the stream execution from running in parallel with other work on the default stream.) See the documentation for torch.Tensor.record_stream() on more details on when to use one or another. Note that this synchronization is necessary even when there is no read dependency, e.g., as seen in this example: cuda = torch.device(\u0027cuda\u0027) s = torch.cuda.Stream() # Create a new stream. A = torch.empty((100, 100), device=cuda) s.wait_stream(torch.cuda.default_stream(cuda)) # STILL REQUIRED! with torch.cuda.stream(s): A.normal_(0.0, 1.0) A.record_stream(s) Despite the computation on s not reading the contents of A and no other uses of A, it is still necessary to synchronize, because A may correspond to memory reallocated by the CUDA caching allocator, with pending operations from the old (deallocated) memory. Stream semantics of backward passes# Each backward CUDA op runs on the same stream that was used for its corresponding forward op. If your forward pass runs independent ops in parallel on different streams, this helps the backward pass exploit that same parallelism. The stream semantics of a backward call with respect to surrounding ops are the same as for any other call. The backward pass inserts internal syncs to ensure this even when backward ops run on multiple streams as described in the previous paragraph. More concretely, when calling autograd.backward, autograd.grad, or tensor.backward, and optionally supplying CUDA tensor(s) as the initial gradient(s) (e.g., autograd.backward(..., grad_tensors=initial_grads), autograd.grad(..., grad_outputs=initial_grads), or tensor.backward(..., gradient=initial_grad)), the acts of optionally populating initial gradient(s), invoking the backward pass, and using the gradients have the same stream-semantics relationship as any group of ops: s = torch.cuda.Stream() # Safe, grads are used in the same stream context as backward() with torch.cuda.stream(s): loss.backward() use grads # Unsafe with torch.cuda.stream(s): loss.backward() use grads # Safe, with synchronization with torch.cuda.stream(s): loss.backward() torch.cuda.current_stream().wait_stream(s) use grads # Safe, populating initial grad and invoking backward are in the same stream context with torch.cuda.stream(s): loss.backward(gradient=torch.ones_like(loss)) # Unsafe, populating initial_grad and invoking backward are in different stream contexts, # without synchronization initial_grad = torch.ones_like(loss) with torch.cuda.stream(s): loss.backward(gradient=initial_grad) # Safe, with synchronization initial_grad = torch.ones_like(loss) s.wait_stream(torch.cuda.current_stream()) with torch.cuda.stream(s): initial_grad.record_stream(s) loss.backward(gradient=initial_grad) BC note: Using grads on the default stream# In prior versions of PyTorch (1.9 and earlier), the autograd engine always synced the default stream with all backward ops, so the following pattern: with torch.cuda.stream(s): loss.backward() use grads was safe as long as use grads happened on the default stream. In present PyTorch, that pattern is no longer safe. If backward() and use grads are in different stream contexts, you must sync the streams: with torch.cuda.stream(s): loss.backward() torch.cuda.current_stream().wait_stream(s) use grads even if use grads is on the default stream. Memory management# PyTorch uses a caching memory allocator to speed up memory allocations. This allows fast memory deallocation without device synchronizations. However, the unused memory managed by the allocator will still show as if used in nvidia-smi. You can use memory_allocated() and max_memory_allocated() to monitor memory occupied by tensors, and use memory_reserved() and max_memory_reserved() to monitor the total amount of memory managed by the caching allocator. Calling empty_cache() releases all unused cached memory from PyTorch so that those can be used by other GPU applications. However, the occupied GPU memory by tensors will not be freed so it can not increase the amount of GPU memory available for PyTorch. To better understand how CUDA memory is being used over time, Understanding CUDA Memory Usage describes tools for capturing and visualizing traces of memory use. For more advanced users, we offer more comprehensive memory benchmarking via memory_stats(). We also offer the capability to capture a complete snapshot of the memory allocator state via memory_snapshot(), which can help you understand the underlying allocation patterns produced by your code. Optimizing memory usage with PYTORCH_ALLOC_CONF# Use of a caching allocator can interfere with memory checking tools such as cuda-memcheck. To debug memory errors using cuda-memcheck, set PYTORCH_NO_CUDA_MEMORY_CACHING=1 in your environment to disable caching. The behavior of the caching allocator can be controlled via the environment variable PYTORCH_ALLOC_CONF. PYTORCH_CUDA_ALLOC_CONF is its alias and is provided only for backward compatibility. The format is PYTORCH_ALLOC_CONF=\u003coption\u003e:\u003cvalue\u003e,\u003coption2\u003e:\u003cvalue2\u003e... Available options: backend allows selecting the underlying allocator implementation. Currently, valid options are native, which uses PyTorch\u2019s native implementation, and cudaMallocAsync, which uses CUDA\u2019s built-in asynchronous allocator. cudaMallocAsync requires CUDA 11.4 or newer. The default is native. backend applies to all devices used by the process, and can\u2019t be specified on a per-device basis. max_split_size_mb prevents the native allocator from splitting blocks larger than this size (in MB). This can reduce fragmentation and may allow some borderline workloads to complete without running out of memory. Performance cost can range from \u2018zero\u2019 to \u2018substantial\u2019 depending on allocation patterns. Default value is unlimited, i.e. all blocks can be split. The memory_stats() and memory_summary() methods are useful for tuning. This option should be used as a last resort for a workload that is aborting due to \u2018out of memory\u2019 and showing a large amount of inactive split blocks. max_split_size_mb is only meaningful with backend:native. With backend:cudaMallocAsync, max_split_size_mb is ignored. roundup_power2_divisions helps with rounding the requested allocation size to nearest power-2 division and making better use of the blocks. In the native CUDACachingAllocator, the sizes are rounded up in multiple of blocks size of 512, so this works fine for smaller sizes. However, this can be inefficient for large near-by allocations as each will go to different size of blocks and reuse of those blocks are minimized. This might create lots of unused blocks and will waste GPU memory capacity. This option enables the rounding of allocation size to nearest power-2 division. For example, if we need to round-up size of 1200 and if number of divisions is 4, the size 1200 lies between 1024 and 2048 and if we do 4 divisions between them, the values are 1024, 1280, 1536, and 1792. So, allocation size of 1200 will be rounded to 1280 as the nearest ceiling of power-2 division. Specify a single value to apply for all allocation sizes or specify an array of key value pairs to set power-2 division individually for each power of two interval. For example to set 1 division for all allocations under 256MB, 2 division for allocations between 256MB and 512MB, 4 divisions for allocations between 512MB and 1GB and 8 divisions for any larger allocations, set the knob value to: [256:1,512:2,1024:4,\u003e:8]. roundup_power2_divisions is only meaningful with backend:native. With backend:cudaMallocAsync, roundup_power2_divisions is ignored. max_non_split_rounding_mb will allow non-split blocks for better reuse, eg,a 1024MB cached block can be reused for a 512MB allocation request. In the default case, we only allow up to 20MB of rounding of non-split blocks, so a 512MB block can only be served with between 512-532 MB size block. If we set the value of this option to 1024, it will allow 512-1536 MB size blocks to be used for a 512MB block which increases reuse of larger blocks. This will also help in reducing the stalls in avoiding expensive cudaMalloc calls. garbage_collection_threshold helps actively reclaiming unused GPU memory to avoid triggering expensive sync-and-reclaim-all operation (release_cached_blocks), which can be unfavorable to latency-critical GPU applications (e.g., servers). Upon setting this threshold (e.g., 0.8), the allocator will start reclaiming GPU memory blocks if the GPU memory capacity usage exceeds the threshold (i.e., 80% of the total memory allocated to the GPU application). The algorithm prefers to free old \u0026 unused blocks first to avoid freeing blocks that are actively being reused. The threshold value should be between greater than 0.0 and less than 1.0. The default value is set at 1.0. garbage_collection_threshold is only meaningful with backend:native. With backend:cudaMallocAsync, garbage_collection_threshold is ignored. expandable_segments (experimental, default: False) If set to True, this setting instructs the allocator to create CUDA allocations that can later be expanded to better handle cases where a job changing allocation sizes frequently, such as having a changing batch size. Normally for large (\u003e2MB) allocations, the allocator calls cudaMalloc to get allocations that are the same size as what the user requests. In the future, parts of these allocations can be reused for other requests if they are free. This works well when the program makes many requests of exactly the same size or of sizes that even multiples of that size. Many deep learning models follow this behavior. However, one common exception is when the batch size changes slightly from one iteration to the next, e.g. in batched inference. When the program runs initially with batch size N, it will make allocations appropriate for that size. If in the future, it runs at size N - 1, the existing allocations will still be big enough. However, if it runs at size N + 1, then it will have to make new allocations that are slightly larger. Not all the tensors are the same size. Some might be (N + 1)*A and others (N + 1)*A*B where A and B are some non-batch dimensions in the model. Because the allocator reuses existing allocations when they are big enough, some number of (N + 1)*A allocations will actually fit in the already existing N*B*A segments, though not perfectly. As the model runs it will partially fill up all of these segments leaving unusable free slices of memory at the end of these segments. The allocator at some point will need to cudaMalloc a new (N + 1)*A*B segment. If there is not enough memory, there is now no way to recover the slices of memory that are free at the end of existing segments. With models 50+ layers deep, this pattern might repeat 50+ times creating many slivers. expandable_segments allows the allocator to create a segment initially and then expand its size later when more memory is needed. Instead of making one segment per allocation, it tries to make one segment (per stream) that grows as necessary. Now when the N + 1 case runs, the allocations will tile nicely into the one large segment until it fills up. Then more memory is requested and appended to the end of the segment. This process does not create as many slivers of unusable memory, so it is more likely to succeed at finding this memory. pinned_use_cuda_host_register option is a boolean flag that determines whether to use the CUDA API\u2019s cudaHostRegister function for allocating pinned memory instead of the default cudaHostAlloc. When set to True, the memory is allocated using regular malloc and then pages are mapped to the memory before calling cudaHostRegister. This pre-mapping of pages helps reduce the lock time during the execution of cudaHostRegister. pinned_num_register_threads option is only valid when pinned_use_cuda_host_register is set to True. By default, one thread is used to map the pages. This option allows using more threads to parallelize the page mapping operations to reduce the overall allocation time of pinned memory. A good value for this option is 8 based on benchmarking results. pinned_use_background_threads option is a boolean flag to enable background thread for processing events. This avoids any slow path associated with querying/processing of events in the fast allocation path. This feature is disabled by default. pinned_reserve_segment_size_mb option is a size in MB to reserve for pinned memory segment. This allocates a large segment of pinned memory upfront and then uses to allocate small size requests. This helps reduce the number of expensive device library calls. graph_capture_record_stream_reuse (experimental, default: False) If set to True, the CUDA caching allocator will attempt to reclaim device memory during CUDA Graph capture by using the graph topology (instead of CUDA events) to determine when a freed block is safe to reuse. This can reduce peak memory during long captures that free and reallocate buffers across multiple streams, especially when the capture DAG frequently reaches joined frontiers. per_process_memory_fraction option limits the amount of memory that can be allocated on all the CUDA devices to a specified fraction of the available memory. This is a value between 0 and 1. Attempting to allocate more memory will raise an out of memory error. Note Some stats reported by the CUDA memory management API are specific to backend:native, and are not meaningful with backend:cudaMallocAsync. See each function\u2019s docstring for details. Using custom memory allocators for CUDA# It is possible to define allocators as simple functions in C/C++ and compile them as a shared library, the code below shows a basic allocator that just traces all the memory operations. #include \u003csys/types.h\u003e #include \u003ccuda_runtime_api.h\u003e #include \u003ciostream\u003e // Compile with g++ alloc.cc -o alloc.so -I/usr/local/cuda/include -shared -fPIC extern \"C\" { void* my_malloc(ssize_t size, int device, cudaStream_t stream) { void *ptr; cudaMalloc(\u0026ptr, size); std::cout\u003c\u003c\"alloc \"\u003c\u003cptr\u003c\u003csize\u003c\u003cstd::endl; return ptr; } void my_free(void* ptr, ssize_t size, int device, cudaStream_t stream) { std::cout\u003c\u003c\"free \"\u003c\u003cptr\u003c\u003c \" \"\u003c\u003cstream\u003c\u003cstd::endl; cudaFree(ptr); } } This can be used in python through the torch.cuda.memory.CUDAPluggableAllocator. The user is responsible for supplying the path to the .so file and the name of the alloc/free functions that match the signatures specified above. import torch # Load the allocator new_alloc = torch.cuda.memory.CUDAPluggableAllocator( \u0027alloc.so\u0027, \u0027my_malloc\u0027, \u0027my_free\u0027) # Swap the current allocator torch.cuda.memory.change_current_allocator(new_alloc) # This will allocate memory in the device using the new allocator b = torch.zeros(10, device=\u0027cuda\u0027) import torch # Do an initial memory allocator b = torch.zeros(10, device=\u0027cuda\u0027) # Load the allocator new_alloc = torch.cuda.memory.CUDAPluggableAllocator( \u0027alloc.so\u0027, \u0027my_malloc\u0027, \u0027my_free\u0027) # This will error since the current allocator was already instantiated torch.cuda.memory.change_current_allocator(new_alloc) Mixing different CUDA system allocators in the same program# Depending on your use case, change_current_allocator() may not be what you want to use, since it swaps the CUDA allocator for the entire program (similar to PYTORCH_ALLOC_CONF=backend:cudaMallocAsync). For instance, if the swapped allocator doesn\u2019t have caching mechanism, you will lose all the benefits of PyTorch\u2019s CUDACachingAllocator. Instead, you can selectively mark a region of PyTorch code to use a custom allocator using torch.cuda.MemPool. This will let you use multiple CUDA system allocators in the same PyTorch program, along with most of the benefits of the CUDACachingAllocator (e.g. caching). Using torch.cuda.MemPool, you can utilize custom allocators that enable several features, such as: Allocating output buffers for an all-reduce using ncclMemAlloc allocator can enable NVLink Switch Reductions (NVLS). This can reduce contention between overlapping compute and communication kernels on GPU resources (SMs, and Copy Engines), especially on tensor-parallel workloads. For Grace CPU based systems, allocating host outputs buffers for an all-gather using cuMemCreate and specifying CU_MEM_LOCATION_TYPE_HOST_NUMA can enable Extended GPU Memory (EGM) based memory transfers from source GPUs to the destination CPU. This accelerates the all-gather since the transfer happens over NVLinks, which otherwise would have happened over bandwidth-limited, Network Interface Card (NIC) links. Such an accelerated all-gather can in turn speed up model checkpointing. If you are crafting a model and don\u2019t want to think about the optimal memory placements of a memory intensive module at first (e.g. an embedding table), or perhaps you have a module which is not performance sensitive and doesn\u2019t fit in the GPU, then you could just allocate that module with cudaMallocManaged with preferred CPU location and get your model working first. Note While cudaMallocManaged offers convenient automatic memory management using CUDA Unified Virtual Memory (UVM), it is not recommended for DL workloads. For DL workloads that fit in GPU memory, explicit placement consistently outperforms UVM, since there are no page faults and access patterns remain predictable. When GPU memory gets saturated, UVM has to perform costly double transfers, evicting pages to CPU before bringing in new ones. The code below shows ncclMemAlloc wrapped in a torch.cuda.memory.CUDAPluggableAllocator. import os import torch import torch.distributed as dist from torch.cuda.memory import CUDAPluggableAllocator from torch.distributed.distributed_c10d import _get_default_group from torch.utils import cpp_extension # create allocator nccl_allocator_source = \"\"\" #include \u003cnccl.h\u003e #include \u003ciostream\u003e extern \"C\" { void* nccl_alloc_plug(size_t size, int device, void* stream) { std::cout \u003c\u003c \"Using ncclMemAlloc\" \u003c\u003c std::endl; void* ptr; ncclResult_t err = ncclMemAlloc(\u0026ptr, size); return ptr; } void nccl_free_plug(void* ptr, size_t size, int device, void* stream) { std::cout \u003c\u003c \"Using ncclMemFree\" \u003c\u003c std::endl; ncclResult_t err = ncclMemFree(ptr); } } \"\"\" nccl_allocator_libname = \"nccl_allocator\" nccl_allocator = torch.utils.cpp_extension.load_inline( name=nccl_allocator_libname, cpp_sources=nccl_allocator_source, with_cuda=True, extra_ldflags=[\"-lnccl\"], verbose=True, is_python_module=False, build_directory=\"./\", ) allocator = CUDAPluggableAllocator( f\"./{nccl_allocator_libname}.so\", \"nccl_alloc_plug\", \"nccl_free_plug\" ).allocator() # setup distributed rank = int(os.getenv(\"RANK\")) local_rank = int(os.getenv(\"LOCAL_RANK\")) world_size = int(os.getenv(\"WORLD_SIZE\")) torch.cuda.set_device(local_rank) dist.init_process_group(backend=\"nccl\") device = torch.device(f\"cuda:{local_rank}\") default_pg = _get_default_group() backend = default_pg._get_backend(device) # Note: for convenience, ProcessGroupNCCL backend provides # the ncclMemAlloc allocator as backend.mem_allocator allocator = backend.mem_allocator You can now define a new memory pool by passing this allocator to torch.cuda.MemPool: pool = torch.cuda.MemPool(allocator) The pool can then be used with the torch.cuda.use_mem_pool context manager to allocate tensors into that pool: with torch.cuda.use_mem_pool(pool): # tensor gets allocated with ncclMemAlloc passed in the pool tensor = torch.arange(1024 * 1024 * 2, device=device) print(f\"tensor ptr on rank {rank} is {hex(tensor.data_ptr())}\") # register user buffers using ncclCommRegister (called under the hood) backend.register_mem_pool(pool) # Collective uses Zero Copy NVLS dist.all_reduce(tensor[0:4]) torch.cuda.synchronize() print(tensor[0:4]) Note the usage of register_mem_pool in the above example. This is an extra step for NVLS reductions, where the user buffers need to be registered with NCCL. A user can de-register the buffers with a similar deregister_mem_pool call. To reclaim memory, users will first need to ensure nothing is using the pool. When none of the tensors are holding a reference to the pool, empty_cache() will be called internally on deletion of the pool, hence returning all the memory to the system. del tensor, del pool Users can optionally specify a use_on_oom bool (which is False by default) during MemPool creation. If true, then the CUDACachingAllocator will be able to use memory in this pool as a last resort instead of OOMing. pool = torch.cuda.MemPool(allocator, use_on_oom=True) with torch.cuda.use_mem_pool(pool): a = torch.randn(40 * 1024 * 1024, dtype=torch.uint8, device=\"cuda\") del a # at the memory limit, this will succeed by using pool\u0027s memory in order to avoid the oom b = torch.randn(40 * 1024 * 1024, dtype=torch.uint8, device=\"cuda\") The following torch.cuda.MemPool.use_count() and torch.cuda.MemPool.snapshot() APIs can be used for debugging purposes: pool = torch.cuda.MemPool(allocator) # pool\u0027s use count should be 1 at this point as MemPool object # holds a reference assert pool.use_count() == 1 nelem_1mb = 1024 * 1024 // 4 with torch.cuda.use_mem_pool(pool): out_0 = torch.randn(nelem_1mb, device=\"cuda\") # pool\u0027s use count should be 2 at this point as use_mem_pool # holds a reference assert pool.use_count() == 2 # pool\u0027s use count should be back to 1 at this point as use_mem_pool # released its reference assert pool.use_count() == 1 with torch.cuda.use_mem_pool(pool): # pool should have 1 segment since we made a small allocation (1 MB) # above and so the CUDACachingAllocator packed it into a 2 MB buffer assert len(pool.snapshot()) == 1 out_1 = torch.randn(nelem_1mb, device=\"cuda\") # pool should still have 1 segment since we made another small allocation # (1 MB) that got packed into the existing 2 MB buffer assert len(pool.snapshot()) == 1 out_2 = torch.randn(nelem_1mb, device=\"cuda\") # pool now should have 2 segments since the CUDACachingAllocator had # to make a new 2 MB buffer to accommodate out_2 assert len(pool.snapshot()) == 2 Note torch.cuda.MemPool holds a reference to the pool. When you use the torch.cuda.use_mem_pool context manager, it will also acquire another reference to the pool. On exit of the context manager, it will release its reference. After that, ideally it should only be tensors holding references to the pool. Once the tensors release their references, the use count of the pool will be 1, reflecting that only the torch.cuda.MemPool object is holding a reference. Only at that point, can the memory held by the pool be returned to the system when the pool\u2019s destructor is called using del. torch.cuda.MemPool doesn\u2019t currently support expandable_segments mode of CUDACachingAllocator. NCCL has specific requirements for a buffer to be compatible with NVLS reductions. These requirements can be broken in a dynamic workload, for instance, the buffer being sent to NCCL by the CUDACachingAllocator might be split and hence, not correctly aligned. In those cases, NCCL can use a fallback algorithm instead of NVLS. Allocators like ncclMemAlloc can use more memory than requested, due to alignment requirements (CU_MULTICAST_GRANULARITY_RECOMMENDED, CU_MULTICAST_GRANULARITY_MINIMUM), and can cause your workload to run out of memory. Tuning NVLink Performance with Custom Memory Allocator on H100/H200 GPUs# In rare cases, performance of NVLink on H100/H200 GPUs can be influenced by the physical memory layout of data, creating an opportunity for developers to tune their applications for optimal throughput. An example of how physical memory layout of data affects performance is when communication kernels issue unbalanced NVLink read/write operations. In the following figure, we can see that each warp accesses memory addresses with a consistent strided pattern in each single wave. We can have a more balanced load by tuning the stride size in the workload or we can implement a custom CUDA allocator. _______________________________ _______________________________ _______________________________ | Warp 0 Reading | No-reading | | Warp 1 Reading | No-reading | ... Warp N Reading | No-reading | _______________________________ _______________________________ _______________________________ \u003c-----------------------------\u003e Stride size Such an allocator can maintain contiguous virtual memory addresses for the kernel while strategically arranging the mapping to physical memory addresses (e.g., through shuffling). This technique allows developers to explore different physical access patterns to find the most efficient one, unlocking higher performance without modifying the kernel\u2019s logic. A practical implementation of such an allocator can be achieved using PyTorch\u2019s custom allocator support as mentioned before, where the malloc and free functions are: // assuming a system with 8 GPUs struct CustomAllocInfo { void** devPtr; // This will be the usable virtual memory address CUdeviceptr dptr; size_t totalSize; // Total size of the allocated memory size_t padded_size; int device_id; std::vector\u003cCUmemGenericAllocationHandle\u003e handles; // Handles to physical memory allocations }; // loop over pages cudaError_t customCudaMalloc(CustomAllocInfo* info) { if (!info) return cudaErrorInvalidValue; CUdeviceptr dptr; // Handles to redundant physical memory allocations which help truncate stride pattern in physical memory std::vector\u003cCUmemGenericAllocationHandle\u003e handles_redundant; size_t granularity = 0; CUmemAllocationProp prop = {}; int currentDev = info-\u003edevice_id; size_t totalSize = info-\u003etotalSize; prop.type = CU_MEM_ALLOCATION_TYPE_PINNED; prop.location.type = CU_MEM_LOCATION_TYPE_DEVICE; prop.location.id = currentDev; cuMemGetAllocationGranularity(\u0026granularity, \u0026prop, CU_MEM_ALLOC_GRANULARITY_MINIMUM); size_t padded_size = ROUND_UP(totalSize, granularity); info-\u003epadded_size = padded_size; // loop over pages size_t iter_granularity = granularity * 64; // 64 * granularity with shift_size = 2 works uint32_t iteration_count = (totalSize + iter_granularity - 1) / iter_granularity; cuMemAddressReserve(\u0026dptr, padded_size, 0ULL, 0ULL, 0ULL); const int shift_size = 2; for (size_t i = 0; i \u003c iteration_count; i+=shift_size) { CUmemGenericAllocationHandle allocHandle[shift_size]; for (int shift = 0; (shift \u003c shift_size)\u0026\u0026(i+shift \u003c iteration_count); shift++){ CHECK_CUDA(cuMemCreate(\u0026allocHandle[shift], iter_granularity, \u0026prop, 0)); info-\u003ehandles.push_back(allocHandle[shift]); } for (int shift = 0; (shift \u003c shift_size)\u0026\u0026(i+shift \u003c iteration_count); shift++){ // mapping makes the shift (shift -\u003e (shift+1)%shift_size ) CHECK_CUDA(cuMemMap(dptr + (i+shift) * iter_granularity, iter_granularity, 0, allocHandle[(shift+1)%shift_size], 0)); setupMultiGPUAccess(dptr + (i+shift) * iter_granularity, iter_granularity, {0, 1, 2, 3, 4, 5, 6, 7}); // Enable access for all 8 GPUs } // std::cout \u003c\u003c \"Here we allocate one redundant page (2MB)...\" \u003c\u003c std::endl; // this is an extra optimization on top of the swizzling. It helps \"break\" // the physical access pattern even more. It can be left out if workload is already // performing at SOL with just swizzling. CUmemGenericAllocationHandle allocHandle_redundant; CHECK_CUDA(cuMemCreate(\u0026allocHandle_redundant, granularity, \u0026prop, 0)); handles_redundant.push_back(allocHandle_redundant); } *info-\u003edevPtr = (void*)dptr; info-\u003edptr = dptr; // Release each redundant allocation for (auto handle : handles_redundant) { // std::cout \u003c\u003c \"Here we release one redundant page (2MB)...\" \u003c\u003c std::endl; CHECK_CUDA(cuMemRelease(handle)); } return cudaSuccess; } void customCudaFree(CustomAllocInfo* info) { if (!info) return; // CHECK_CUDA(cudaSetDevice(info-\u003edevice_id)); CHECK_CUDA(cuMemUnmap(info-\u003edptr, info-\u003epadded_size)); // Unmap and release each allocation for (auto handle : info-\u003ehandles) { CHECK_CUDA(cuMemRelease(handle)); } // Unreserve the virtual address space // CHECK_CUDA(cuMemAddressFree((CUdeviceptr)*info-\u003edevPtr, info-\u003epadded_size)); CHECK_CUDA(cuMemAddressFree(info-\u003edptr, info-\u003epadded_size)); } cuBLAS workspaces# For each combination of cuBLAS handle and CUDA stream, a cuBLAS workspace will be allocated if that handle and stream combination executes a cuBLAS kernel that requires a workspace. In order to avoid repeatedly allocating workspaces, these workspaces are not deallocated unless torch._C._cuda_clearCublasWorkspaces() is called. The workspace size per allocation can be specified via the environment variable CUBLAS_WORKSPACE_CONFIG with the format :[SIZE]:[COUNT]. As an example, the default workspace size per allocation is CUBLAS_WORKSPACE_CONFIG=:4096:2:16:8 which specifies a total size of 2 * 4096 + 8 * 16 KiB. To force cuBLAS to avoid using workspaces, set CUBLAS_WORKSPACE_CONFIG=:0:0. cuFFT plan cache# For each CUDA device, an LRU cache of cuFFT plans is used to speed up repeatedly running FFT methods (e.g., torch.fft.fft()) on CUDA tensors of same geometry with same configuration. Because some cuFFT plans may allocate GPU memory, these caches have a maximum capacity. You may control and query the properties of the cache of current device with the following APIs: torch.backends.cuda.cufft_plan_cache.max_size gives the capacity of the cache (default is 4096 on CUDA 10 and newer, and 1023 on older CUDA versions). Setting this value directly modifies the capacity. torch.backends.cuda.cufft_plan_cache.size gives the number of plans currently residing in the cache. torch.backends.cuda.cufft_plan_cache.clear() clears the cache. To control and query plan caches of a non-default device, you can index the torch.backends.cuda.cufft_plan_cache object with either a torch.device object or a device index, and access one of the above attributes. E.g., to set the capacity of the cache for device 1, one can write torch.backends.cuda.cufft_plan_cache[1].max_size = 10. Just-in-Time Compilation# PyTorch just-in-time compiles some operations, like torch.special.zeta, when performed on CUDA tensors. This compilation can be time consuming (up to a few seconds depending on your hardware and software) and may occur multiple times for a single operator since many PyTorch operators actually select from a variety of kernels, each of which must be compiled once, depending on their input. This compilation occurs once per process, or just once if a kernel cache is used. By default, PyTorch creates a kernel cache in $XDG_CACHE_HOME/torch/kernels if XDG_CACHE_HOME is defined and $HOME/.cache/torch/kernels if it\u2019s not (except on Windows, where the kernel cache is not yet supported). The caching behavior can be directly controlled with two environment variables. If USE_PYTORCH_KERNEL_CACHE is set to 0 then no cache will be used, and if PYTORCH_KERNEL_CACHE_PATH is set then that path will be used as a kernel cache instead of the default location. Best practices# Device-agnostic code# Due to the structure of PyTorch, you may need to explicitly write device-agnostic (CPU or GPU) code; an example may be creating a new tensor as the initial hidden state of a recurrent neural network. The first step is to determine whether the GPU should be used or not. A common pattern is to use Python\u2019s argparse module to read in user arguments, and have a flag that can be used to disable CUDA, in combination with is_available(). In the following, args.device results in a torch.device object that can be used to move tensors to CPU or CUDA. import argparse import torch parser = argparse.ArgumentParser(description=\u0027PyTorch Example\u0027) parser.add_argument(\u0027--disable-cuda\u0027, action=\u0027store_true\u0027, help=\u0027Disable CUDA\u0027) args = parser.parse_args() args.device = None if not args.disable_cuda and torch.cuda.is_available(): args.device = torch.device(\u0027cuda\u0027) else: args.device = torch.device(\u0027cpu\u0027) Note When assessing the availability of CUDA in a given environment (is_available()), PyTorch\u2019s default behavior is to call the CUDA Runtime API method cudaGetDeviceCount. Because this call in turn initializes the CUDA Driver API (via cuInit) if it is not already initialized, subsequent forks of a process that has run is_available() will fail with a CUDA initialization error. One can set PYTORCH_NVML_BASED_CUDA_CHECK=1 in your environment before importing PyTorch modules that execute is_available() (or before executing it directly) in order to direct is_available() to attempt an NVML-based assessment (nvmlDeviceGetCount_v2). If the NVML-based assessment is successful (i.e. NVML discovery/initialization does not fail), is_available() calls will not poison subsequent forks. If NVML discovery/initialization fails, is_available() will fallback to the standard CUDA Runtime API assessment and the aforementioned fork constraint will apply. Note that the above NVML-based CUDA availability assessment provides a weaker guarantee than the default CUDA Runtime API approach (which requires CUDA initialization to succeed). In some circumstances, the NVML-based check may succeed while later CUDA initialization fails. Now that we have args.device, we can use it to create a Tensor on the desired device. x = torch.empty((8, 42), device=args.device) net = Network().to(device=args.device) This can be used in a number of cases to produce device agnostic code. Below is an example when using a dataloader: cuda0 = torch.device(\u0027cuda:0\u0027) # CUDA GPU 0 for i, x in enumerate(train_loader): x = x.to(cuda0) When working with multiple GPUs on a system, you can use the CUDA_VISIBLE_DEVICES environment flag to manage which GPUs are available to PyTorch. As mentioned above, to manually control which GPU a tensor is created on, the best practice is to use a torch.cuda.device context manager. print(\"Outside device is 0\") # On device 0 (default in most scenarios) with torch.cuda.device(1): print(\"Inside device is 1\") # On device 1 print(\"Outside device is still 0\") # On device 0 If you have a tensor and would like to create a new tensor of the same type on the same device, then you can use a torch.Tensor.new_* method (see torch.Tensor). Whilst the previously mentioned torch.* factory functions (Creation Ops) depend on the current GPU context and the attributes arguments you pass in, torch.Tensor.new_* methods preserve the device and other attributes of the tensor. This is the recommended practice when creating modules in which new tensors need to be created internally during the forward pass. cuda = torch.device(\u0027cuda\u0027) x_cpu = torch.empty(2) x_gpu = torch.empty(2, device=cuda) x_cpu_long = torch.empty(2, dtype=torch.int64) y_cpu = x_cpu.new_full([3, 2], fill_value=0.3) print(y_cpu) tensor([[ 0.3000, 0.3000], [ 0.3000, 0.3000], [ 0.3000, 0.3000]]) y_gpu = x_gpu.new_full([3, 2], fill_value=-5) print(y_gpu) tensor([[-5.0000, -5.0000], [-5.0000, -5.0000], [-5.0000, -5.0000]], device=\u0027cuda:0\u0027) y_cpu_long = x_cpu_long.new_tensor([[1, 2, 3]]) print(y_cpu_long) tensor([[ 1, 2, 3]]) If you want to create a tensor of the same type and size of another tensor, and fill it with either ones or zeros, ones_like() or zeros_like() are provided as convenient helper functions (which also preserve torch.device and torch.dtype of a Tensor). x_cpu = torch.empty(2, 3) x_gpu = torch.empty(2, 3) y_cpu = torch.ones_like(x_cpu) y_gpu = torch.zeros_like(x_gpu) Use pinned memory buffers# Warning This is an advanced tip. If you overuse pinned memory, it can cause serious problems when running low on RAM, and you should be aware that pinning is often an expensive operation. Host to GPU copies are much faster when they originate from pinned (page-locked) memory. CPU tensors and storages expose a pin_memory() method, that returns a copy of the object, with data put in a pinned region. Also, once you pin a tensor or storage, you can use asynchronous GPU copies. Just pass an additional non_blocking=True argument to a to() or a cuda() call. This can be used to overlap data transfers with computation. You can make the DataLoader return batches placed in pinned memory by passing pin_memory=True to its constructor. Use nn.parallel.DistributedDataParallel instead of multiprocessing or nn.DataParallel# Most use cases involving batched inputs and multiple GPUs should default to using DistributedDataParallel to utilize more than one GPU. There are significant caveats to using CUDA models with multiprocessing; unless care is taken to meet the data handling requirements exactly, it is likely that your program will have incorrect or undefined behavior. It is recommended to use DistributedDataParallel, instead of DataParallel to do multi-GPU training, even if there is only a single node. The difference between DistributedDataParallel and DataParallel is: DistributedDataParallel uses multiprocessing where a process is created for each GPU, while DataParallel uses multithreading. By using multiprocessing, each GPU has its dedicated process, this avoids the performance overhead caused by GIL of Python interpreter. If you use DistributedDataParallel, you could use torch.distributed.launch utility to launch your program, see Launch utility. CUDA Graphs# A CUDA graph is a record of the work (mostly kernels and their arguments) that a CUDA stream and its dependent streams perform. For general principles and details on the underlying CUDA API, see Getting Started with CUDA Graphs and the Graphs section of the CUDA C Programming Guide. PyTorch supports the construction of CUDA graphs using stream capture, which puts a CUDA stream in capture mode. CUDA work issued to a capturing stream doesn\u2019t actually run on the GPU. Instead, the work is recorded in a graph. After capture, the graph can be launched to run the GPU work as many times as needed. Each replay runs the same kernels with the same arguments. For pointer arguments this means the same memory addresses are used. By filling input memory with new data (e.g., from a new batch) before each replay, you can rerun the same work on new data. Why CUDA Graphs?# Replaying a graph sacrifices the dynamic flexibility of typical eager execution in exchange for greatly reduced CPU overhead. A graph\u2019s arguments and kernels are fixed, so a graph replay skips all layers of argument setup and kernel dispatch, including Python, C++, and CUDA driver overheads. Under the hood, a replay submits the entire graph\u2019s work to the GPU with a single call to cudaGraphLaunch. Kernels in a replay also execute slightly faster on the GPU, but eliding CPU overhead is the main benefit. You should try CUDA graphs if all or part of your network is graph-safe (usually this means static shapes and static control flow, but see the other constraints) and you suspect its runtime is at least somewhat CPU-limited. PyTorch API# Warning This API is in beta and may change in future releases. PyTorch exposes graphs via a raw torch.cuda.CUDAGraph class and two convenience wrappers, torch.cuda.graph and torch.cuda.make_graphed_callables. torch.cuda.graph is a simple, versatile context manager that captures CUDA work in its context. Before capture, warm up the workload to be captured by running a few eager iterations. Warmup must occur on a side stream. Because the graph reads from and writes to the same memory addresses in every replay, you must maintain long-lived references to tensors that hold input and output data during capture. To run the graph on new input data, copy new data to the capture\u2019s input tensor(s), replay the graph, then read the new output from the capture\u2019s output tensor(s). Example: g = torch.cuda.CUDAGraph() # Placeholder input used for capture static_input = torch.empty((5,), device=\"cuda\") # Warmup before capture s = torch.cuda.Stream() s.wait_stream(torch.cuda.current_stream()) with torch.cuda.stream(s): for _ in range(3): static_output = static_input * 2 torch.cuda.current_stream().wait_stream(s) # Captures the graph # To allow capture, automatically sets a side stream as the current stream in the context with torch.cuda.graph(g): static_output = static_input * 2 # Fills the graph\u0027s input memory with new data to compute on static_input.copy_(torch.full((5,), 3, device=\"cuda\")) g.replay() # static_output holds the results print(static_output) # full of 3 * 2 = 6 # Fills the graph\u0027s input memory with more data to compute on static_input.copy_(torch.full((5,), 4, device=\"cuda\")) g.replay() print(static_output) # full of 4 * 2 = 8 See Whole-network capture, Usage with torch.cuda.amp, and Usage with multiple streams for realistic and advanced patterns. make_graphed_callables is more sophisticated. make_graphed_callables accepts Python functions and torch.nn.Modules. For each passed function or Module, it creates separate graphs of the forward-pass and backward-pass work. See Partial-network capture. Constraints# A set of ops is capturable if it doesn\u2019t violate any of the following constraints. Constraints apply to all work in a torch.cuda.graph context and all work in the forward and backward passes of any callable you pass to torch.cuda.make_graphed_callables(). Violating any of these will likely cause a runtime error: Capture must occur on a non-default stream. (This is only a concern if you use the raw CUDAGraph.capture_begin and CUDAGraph.capture_end calls. graph and make_graphed_callables() set a side stream for you.) Ops that synchronize the CPU with the GPU (e.g., .item() calls) are prohibited. CUDA RNG operations are permitted, and when using multiple torch.Generator instances within a graph, they must be registered using CUDAGraph.register_generator_state before graph capture. Avoid using Generator.get_state and Generator.set_state during capture; instead, utilize Generator.graphsafe_set_state and Generator.graphsafe_get_state for managing generator states safely within the graph context. This ensures proper RNG operation and generator management within CUDA graphs. Violating any of these will likely cause silent numerical errors or undefined behavior: Within a process, only one capture may be underway at a time. No non-captured CUDA work may run in this process (on any thread) while capture is underway. CPU work is not captured. If the captured ops include CPU work, that work will be elided during replay. Every replay reads from and writes to the same (virtual) memory addresses. Dynamic control flow (based on CPU or GPU data) is prohibited. Dynamic shapes are prohibited. The graph assumes every tensor in the captured op sequence has the same size and layout in every replay. Using multiple streams in a capture is allowed, but there are restrictions. Non-constraints# Once captured, the graph may be replayed on any stream. Whole-network capture# If your entire network is capturable, you can capture and replay an entire iteration: N, D_in, H, D_out = 640, 4096, 2048, 1024 model = torch.nn.Sequential(torch.nn.Linear(D_in, H), torch.nn.Dropout(p=0.2), torch.nn.Linear(H, D_out), torch.nn.Dropout(p=0.1)).cuda() loss_fn = torch.nn.MSELoss() optimizer = torch.optim.SGD(model.parameters(), lr=0.1) # Placeholders used for capture static_input = torch.randn(N, D_in, device=\u0027cuda\u0027) static_target = torch.randn(N, D_out, device=\u0027cuda\u0027) # warmup # Uses static_input and static_target here for convenience, # but in a real setting, because the warmup includes optimizer.step() # you must use a few batches of real data. s = torch.cuda.Stream() s.wait_stream(torch.cuda.current_stream()) with torch.cuda.stream(s): for i in range(3): optimizer.zero_grad(set_to_none=True) y_pred = model(static_input) loss = loss_fn(y_pred, static_target) loss.backward() optimizer.step() torch.cuda.current_stream().wait_stream(s) # capture g = torch.cuda.CUDAGraph() # Sets grads to None before capture, so backward() will create # .grad attributes with allocations from the graph\u0027s private pool optimizer.zero_grad(set_to_none=True) with torch.cuda.graph(g): static_y_pred = model(static_input) static_loss = loss_fn(static_y_pred, static_target) static_loss.backward() optimizer.step() real_inputs = [torch.rand_like(static_input) for _ in range(10)] real_targets = [torch.rand_like(static_target) for _ in range(10)] for data, target in zip(real_inputs, real_targets): # Fills the graph\u0027s input memory with new data to compute on static_input.copy_(data) static_target.copy_(target) # replay() includes forward, backward, and step. # You don\u0027t even need to call optimizer.zero_grad() between iterations # because the captured backward refills static .grad tensors in place. g.replay() # Params have been updated. static_y_pred, static_loss, and .grad # attributes hold values from computing on this iteration\u0027s data. Partial-network capture# If some of your network is unsafe to capture (e.g., due to dynamic control flow, dynamic shapes, CPU syncs, or essential CPU-side logic), you can run the unsafe part(s) eagerly and use torch.cuda.make_graphed_callables() to graph only the capture-safe part(s). By default, callables returned by make_graphed_callables() are autograd-aware, and can be used in the training loop as direct replacements for the functions or nn.Modules you passed. make_graphed_callables() internally creates CUDAGraph objects, runs warmup iterations, and maintains static inputs and outputs as needed. Therefore (unlike with torch.cuda.graph) you don\u2019t need to handle those manually. In the following example, data-dependent dynamic control flow means the network isn\u2019t capturable end-to-end, but make_graphed_callables() lets us capture and run graph-safe sections as graphs regardless: N, D_in, H, D_out = 640, 4096, 2048, 1024 module1 = torch.nn.Linear(D_in, H).cuda() module2 = torch.nn.Linear(H, D_out).cuda() module3 = torch.nn.Linear(H, D_out).cuda() loss_fn = torch.nn.MSELoss() optimizer = torch.optim.SGD(chain(module1.parameters(), module2.parameters(), module3.parameters()), lr=0.1) # Sample inputs used for capture # requires_grad state of sample inputs must match # requires_grad state of real inputs each callable will see. x = torch.randn(N, D_in, device=\u0027cuda\u0027) h = torch.randn(N, H, device=\u0027cuda\u0027, requires_grad=True) module1 = torch.cuda.make_graphed_callables(module1, (x,)) module2 = torch.cuda.make_graphed_callables(module2, (h,)) module3 = torch.cuda.make_graphed_callables(module3, (h,)) real_inputs = [torch.rand_like(x) for _ in range(10)] real_targets = [torch.randn(N, D_out, device=\"cuda\") for _ in range(10)] for data, target in zip(real_inputs, real_targets): optimizer.zero_grad(set_to_none=True) tmp = module1(data) # forward ops run as a graph if tmp.sum().item() \u003e 0: tmp = module2(tmp) # forward ops run as a graph else: tmp = module3(tmp) # forward ops run as a graph loss = loss_fn(tmp, target) # module2\u0027s or module3\u0027s (whichever was chosen) backward ops, # as well as module1\u0027s backward ops, run as graphs loss.backward() optimizer.step() Usage with torch.cuda.amp# For typical optimizers, GradScaler.step syncs the CPU with the GPU, which is prohibited during capture. To avoid errors, either use partial-network capture, or (if forward, loss, and backward are capture-safe) capture forward, loss, and backward but not the optimizer step: # warmup # In a real setting, use a few batches of real data. s = torch.cuda.Stream() s.wait_stream(torch.cuda.current_stream()) with torch.cuda.stream(s): for i in range(3): optimizer.zero_grad(set_to_none=True) with torch.cuda.amp.autocast(): y_pred = model(static_input) loss = loss_fn(y_pred, static_target) scaler.scale(loss).backward() scaler.step(optimizer) scaler.update() torch.cuda.current_stream().wait_stream(s) # capture g = torch.cuda.CUDAGraph() optimizer.zero_grad(set_to_none=True) with torch.cuda.graph(g): with torch.cuda.amp.autocast(): static_y_pred = model(static_input) static_loss = loss_fn(static_y_pred, static_target) scaler.scale(static_loss).backward() # don\u0027t capture scaler.step(optimizer) or scaler.update() real_inputs = [torch.rand_like(static_input) for _ in range(10)] real_targets = [torch.rand_like(static_target) for _ in range(10)] for data, target in zip(real_inputs, real_targets): static_input.copy_(data) static_target.copy_(target) g.replay() # Runs scaler.step and scaler.update eagerly scaler.step(optimizer) scaler.update() Usage with multiple streams# Capture mode automatically propagates to any streams that sync with a capturing stream. Within capture, you may expose parallelism by issuing calls to different streams, but the overall stream dependency DAG must branch out from the initial capturing stream after capture begins and rejoin the initial stream before capture ends: with torch.cuda.graph(g): # at context manager entrance, torch.cuda.current_stream() # is the initial capturing stream # INCORRECT (does not branch out from or rejoin initial stream) with torch.cuda.stream(s): cuda_work() # CORRECT: # branches out from initial stream s.wait_stream(torch.cuda.current_stream()) with torch.cuda.stream(s): cuda_work() # rejoins initial stream before capture ends torch.cuda.current_stream().wait_stream(s) Note To avoid confusion for power users looking at replays in nsight systems or nvprof: Unlike eager execution, the graph interprets a nontrivial stream DAG in capture as a hint, not a command. During replay, the graph may reorganize independent ops onto different streams or enqueue them in a different order (while respecting your original DAG\u2019s overall dependencies). Usage with DistributedDataParallel# NCCL \u003c 2.9.6# NCCL versions earlier than 2.9.6 don\u2019t allow collectives to be captured. You must use partial-network capture, which defers allreduces to happen outside graphed sections of backward. Call make_graphed_callables() on graphable network sections before wrapping the network with DDP. NCCL \u003e= 2.9.6# NCCL versions 2.9.6 or later allow collectives in the graph. Approaches that capture an entire backward pass are a viable option, but need three setup steps. Disable DDP\u2019s internal async error handling: os.environ[\"NCCL_ASYNC_ERROR_HANDLING\"] = \"0\" torch.distributed.init_process_group(...) Before full-backward capture, DDP must be constructed in a side-stream context: with torch.cuda.stream(s): model = DistributedDataParallel(model) Your warmup must run at least 11 DDP-enabled eager iterations before capture. Graph memory management# A captured graph acts on the same virtual addresses every time it replays. If PyTorch frees the memory, a later replay can hit an illegal memory access. If PyTorch reassigns the memory to new tensors, the replay can corrupt the values seen by those tensors. Therefore, the virtual addresses used by the graph must be reserved for the graph across replays. The PyTorch caching allocator achieves this by detecting when capture is underway and satisfying the capture\u2019s allocations from a graph-private memory pool. The private pool stays alive until its CUDAGraph object and all tensors created during capture go out of scope. Private pools are maintained automatically. By default, the allocator creates a separate private pool for each capture. If you capture multiple graphs, this conservative approach ensures graph replays never corrupt each other\u2019s values, but sometimes needlessly wastes memory. Sharing memory across captures# To economize the memory stashed in private pools, torch.cuda.graph and torch.cuda.make_graphed_callables() optionally allow different captures to share the same private pool. It\u2019s safe for a set of graphs to share a private pool if you know they\u2019ll always be replayed in the same order they were captured, and never be replayed concurrently. torch.cuda.graph\u2019s pool argument is a hint to use a particular private pool, and can be used to share memory across graphs as shown: g1 = torch.cuda.CUDAGraph() g2 = torch.cuda.CUDAGraph() # (create static inputs for g1 and g2, run warmups of their workloads...) # Captures g1 with torch.cuda.graph(g1): static_out_1 = g1_workload(static_in_1) # Captures g2, hinting that g2 may share a memory pool with g1 with torch.cuda.graph(g2, pool=g1.pool()): static_out_2 = g2_workload(static_in_2) static_in_1.copy_(real_data_1) static_in_2.copy_(real_data_2) g1.replay() g2.replay() It\u2019s also safe to share a memory pool across separate graphs that do not depend on each other\u2019s outputs, provided they never run concurrently. Be aware that replaying one graph can clobber another graph\u2019s outputs when they share a pool, unless clone() is called on the outputs beforehand. This pattern is frequently used in inference servers that accept variable batch sizes at runtime. vLLM is a notable example; see here and here. With torch.cuda.make_graphed_callables(), if you want to graph several callables and you know they\u2019ll always run in the same order (and never concurrently) pass them as a tuple in the same order they\u2019ll run in the live workload, and make_graphed_callables() will capture their graphs using a shared private pool. If, in the live workload, your callables will run in an order that occasionally changes, or if they\u2019ll run concurrently, passing them as a tuple to a single invocation of make_graphed_callables() is not allowed. Instead, you must call make_graphed_callables() separately for each one.",
       "author": {
         "@type": "Organization",
         "name": "PyTorch Contributors",
         "url": "https://pytorch.org"
       },
       "image": "https://pytorch.org/docs/stable/_static/img/pytorch_seo.png",
       "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "/notes/cuda.html"
       },
       "datePublished": "Jan 16, 2017T00:00:00Z",
       "dateModified": "Dec 09, 2025T00:00:00Z"
     }
 </script>
  <script>
    // Tutorials Call to action event tracking
    $("[data-behavior='call-to-action-event']").on('click', function () {
      fbq('trackCustom', "Download", {
        tutorialTitle: $('h1:first').text(),
        downloadLink: this.href,
        tutorialLink: window.location.href,
        downloadTitle: $(this).attr("data-response")
      });
      if (typeof gtag === 'function') {
        gtag('event', 'click', {
          'event_category': $(this).attr("data-response"),
          'event_label': $("h1").first().text(),
          'tutorial_link': window.location.href
        });
      }
    });
  </script>
  
  </body>
</html>